explicit-sync-ng branch from emersion (https://gitlab.freedesktop.org/emersion/wlroots/-/tree/explicit-sync-ng?ref_type=heads)

commit 2ab93c05a5e4ea05d2772be5683699e43fe05781
Author: Simon Ser <contact@emersion.fr>
Date:   Sun Aug 4 16:23:53 2024 +0200

    render: add WLR_RENDER_NO_EXPLICIT_SYNC env var

    This can be handy to figure out if a bug is due to explicit sync.

commit 2d8ebeab45f867d268c4362b7e37acc49ee6a028
Author: Simon Ser <contact@emersion.fr>
Date:   Fri May 10 18:32:04 2024 +0200

    cursor: add support for linux-drm-syncobj-v1

commit 2b4dee944641d0cb1a6cb87ae92ec0bcb526effd
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 15:08:44 2024 +0200

    scene: add explicit synchronization for rendered buffers

commit 5fb259b8a9867c01104092f0fd88c7e5ffc56ba5
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 14:37:12 2024 +0200

    scene: add support for linux-drm-syncobj-v1

commit 86f5e15c2de312422fde61511c47008cb86633bb
Author: Simon Ser <contact@emersion.fr>
Date:   Fri May 10 16:46:15 2024 +0200

    linux-drm-syncobj-v1: add helper to signal on buffer release

commit 0a6e8b881bb2b38bceab4a216c5f61c9ca8c4047
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 14:32:30 2024 +0200

    scene: add wlr_scene_buffer_set_wait_timeline()

commit 9d8be86a4a69cbc32e7827834347d717ad586689
Author: Simon Ser <contact@emersion.fr>
Date:   Tue Feb 27 18:38:12 2024 +0100

    render/drm_syncobj: add wlr_drm_syncobj_timeline_export()

commit df1a01287d2fc3f25e71f0da3b848d1de007c0e0
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Oct 21 15:23:20 2021 +0200

    render/drm_syncobj: add wlr_drm_syncobj_timeline_transfer()

commit 2e717d6f76b30659fb5e039766c5e0e19800346f
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 20:09:38 2021 +0200

    backend/drm: add support for explicit sync APIs

commit c45e72513319dd7b7200bf797860cb87c218cc76
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 19:29:00 2021 +0200

    output: add explicit sync API

commit bc3202baa285dd24f67b55f9827cd43dcb8571ab
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 16:15:59 2023 +0200

    render/gles2: implement explicit sync API

commit aa2aabe7585d55becc878aecafedaac0cd8fb38b
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Mar 16 17:24:25 2020 +0100

    render/egl: add support for explicit sync extensions

commit 14239eb72d0617a634cedb0239a093c3dc92a22c
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 10:53:12 2023 +0200

    render: add explicit sync API
---
 backend/drm/atomic.c                         | 62 +++++++++++++++-
 backend/drm/drm.c                            | 10 ++-
 backend/drm/properties.c                     |  2 +
 docs/env_vars.md                             |  2 +
 include/backend/drm/drm.h                    |  1 +
 include/backend/drm/properties.h             |  2 +
 include/render/egl.h                         | 12 ++++
 include/render/gles2.h                       |  5 +-
 include/types/wlr_output.h                   |  3 +-
 include/wlr/render/drm_syncobj.h             | 11 +++
 include/wlr/render/pass.h                    | 22 ++++++
 include/wlr/render/wlr_renderer.h            |  6 ++
 include/wlr/types/wlr_linux_drm_syncobj_v1.h |  9 +++
 include/wlr/types/wlr_output.h               | 38 ++++++++++
 include/wlr/types/wlr_scene.h                |  9 +++
 render/drm_syncobj.c                         | 22 ++++++
 render/egl.c                                 | 74 ++++++++++++++++++++
 render/gles2/pass.c                          | 60 +++++++++++++++-
 render/gles2/renderer.c                      |  6 +-
 render/wlr_renderer.c                        |  3 +
 types/output/cursor.c                        | 21 +++++-
 types/output/output.c                        | 22 +++++-
 types/output/state.c                         | 34 ++++++++-
 types/scene/surface.c                        | 18 +++++
 types/scene/wlr_scene.c                      | 37 +++++++++-
 types/wlr_cursor.c                           | 20 +++++-
 types/wlr_linux_drm_syncobj_v1.c             | 37 ++++++++++
 27 files changed, 529 insertions(+), 19 deletions(-)

diff --git a/backend/drm/atomic.c b/backend/drm/atomic.c
index 2649a1a554f033fa049e0917b9d26c033c6f1144..d3a91efbe1c2f2686b91ccad426dc4c24c9793f2 100644
--- a/backend/drm/atomic.c
+++ b/backend/drm/atomic.c
@@ -1,6 +1,8 @@
 #include <drm_fourcc.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/util/log.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
@@ -272,6 +274,15 @@ bool drm_atomic_connector_prepare(struct wlr_drm_connector_state *state, bool mo
 			state->primary_fb->wlr_buf->height, &state->base->damage, &fb_damage_clips);
 	}
 
+	int in_fence_fd = -1;
+	if (state->base->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+		in_fence_fd = wlr_drm_syncobj_timeline_export_sync_file(state->base->wait_timeline,
+			state->base->wait_point);
+		if (in_fence_fd < 0) {
+			return false;
+		}
+	}
+
 	bool prev_vrr_enabled =
 		output->adaptive_sync_status == WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED;
 	bool vrr_enabled = prev_vrr_enabled;
@@ -285,6 +296,7 @@ bool drm_atomic_connector_prepare(struct wlr_drm_connector_state *state, bool mo
 	state->mode_id = mode_id;
 	state->gamma_lut = gamma_lut;
 	state->fb_damage_clips = fb_damage_clips;
+	state->primary_in_fence_fd = in_fence_fd;
 	state->vrr_enabled = vrr_enabled;
 	return true;
 }
@@ -305,6 +317,15 @@ void drm_atomic_connector_apply_commit(struct wlr_drm_connector_state *state) {
 		WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED : WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED;
 
 	destroy_blob(drm, state->fb_damage_clips);
+	if (state->primary_in_fence_fd >= 0) {
+		close(state->primary_in_fence_fd);
+	}
+	if (state->out_fence_fd >= 0) {
+		// TODO: error handling
+		wlr_drm_syncobj_timeline_import_sync_file(state->base->signal_timeline,
+			state->base->signal_point, state->out_fence_fd);
+		close(state->out_fence_fd);
+	}
 }
 
 void drm_atomic_connector_rollback_commit(struct wlr_drm_connector_state *state) {
@@ -316,6 +337,12 @@ void drm_atomic_connector_rollback_commit(struct wlr_drm_connector_state *state)
 	rollback_blob(drm, &crtc->gamma_lut, state->gamma_lut);
 
 	destroy_blob(drm, state->fb_damage_clips);
+	if (state->primary_in_fence_fd >= 0) {
+		close(state->primary_in_fence_fd);
+	}
+	if (state->out_fence_fd >= 0) {
+		close(state->out_fence_fd);
+	}
 }
 
 static void plane_disable(struct atomic *atom, struct wlr_drm_plane *plane) {
@@ -353,12 +380,37 @@ static void set_plane_props(struct atomic *atom, struct wlr_drm_backend *drm,
 	atomic_add(atom, id, props->crtc_y, (uint64_t)y);
 }
 
-static bool supports_cursor_hotspots(const struct wlr_drm_plane* plane) {
+static bool supports_cursor_hotspots(const struct wlr_drm_plane *plane) {
 	return plane->props.hotspot_x && plane->props.hotspot_y;
 }
 
+static void set_plane_in_fence_fd(struct atomic *atom,
+		struct wlr_drm_plane *plane, int sync_file_fd) {
+	if (!plane->props.in_fence_fd) {
+		wlr_log(WLR_ERROR, "Plane %"PRIu32 " is missing the IN_FENCE_FD property",
+			plane->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, plane->id, plane->props.in_fence_fd, sync_file_fd);
+}
+
+static void set_crtc_out_fence_ptr(struct atomic *atom, struct wlr_drm_crtc *crtc,
+		int *fd_ptr) {
+	if (!crtc->props.out_fence_ptr) {
+		wlr_log(WLR_ERROR,
+			"CRTC %"PRIu32" is missing the OUT_FENCE_PTR property",
+			crtc->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, crtc->id, crtc->props.out_fence_ptr, (uintptr_t)fd_ptr);
+}
+
 static void atomic_connector_add(struct atomic *atom,
-		const struct wlr_drm_connector_state *state, bool modeset) {
+		struct wlr_drm_connector_state *state, bool modeset) {
 	struct wlr_drm_connector *conn = state->connector;
 	struct wlr_drm_backend *drm = conn->backend;
 	struct wlr_drm_crtc *crtc = conn->crtc;
@@ -391,6 +443,12 @@ static void atomic_connector_add(struct atomic *atom,
 			atomic_add(atom, crtc->primary->id,
 				crtc->primary->props.fb_damage_clips, state->fb_damage_clips);
 		}
+		if (state->primary_in_fence_fd >= 0) {
+			set_plane_in_fence_fd(atom, crtc->primary, state->primary_in_fence_fd);
+		}
+		if (state->base->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			set_crtc_out_fence_ptr(atom, crtc, &state->out_fence_fd);
+		}
 		if (crtc->cursor) {
 			if (drm_connector_is_cursor_visible(conn)) {
 				set_plane_props(atom, drm, crtc->cursor, state->cursor_fb,
diff --git a/backend/drm/drm.c b/backend/drm/drm.c
index 5756f289750ce8cfa03a9cc58174e51c42a643fc..4104f87c7ae275fdcd508861182908f3118bc017 100644
--- a/backend/drm/drm.c
+++ b/backend/drm/drm.c
@@ -42,7 +42,9 @@ static const uint32_t COMMIT_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_ENABLED |
 	WLR_OUTPUT_STATE_GAMMA_LUT |
 	WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED |
-	WLR_OUTPUT_STATE_LAYERS;
+	WLR_OUTPUT_STATE_LAYERS |
+	WLR_OUTPUT_STATE_WAIT_TIMELINE |
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
 
 static const uint32_t SUPPORTED_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_BACKEND_OPTIONAL | COMMIT_OUTPUT_STATE;
@@ -630,6 +632,8 @@ static void drm_connector_state_init(struct wlr_drm_connector_state *state,
 		.connector = conn,
 		.base = base,
 		.active = output_pending_enabled(&conn->output, base),
+		.primary_in_fence_fd = -1,
+		.out_fence_fd = -1,
 	};
 
 	struct wlr_output_mode *mode = conn->output.current_mode;
@@ -1619,6 +1623,10 @@ static bool connect_drm_connector(struct wlr_drm_connector *wlr_conn,
 		output->non_desktop = non_desktop;
 	}
 
+	// TODO: support sync timelines in multi-GPU mode
+	// TODO: support sync timelines with libliftoff
+	output->timeline = drm->parent == NULL && drm->iface == &atomic_iface;
+
 	memset(wlr_conn->max_bpc_bounds, 0, sizeof(wlr_conn->max_bpc_bounds));
 	if (wlr_conn->props.max_bpc != 0) {
 		if (!introspect_drm_prop_range(drm->fd, wlr_conn->props.max_bpc,
diff --git a/backend/drm/properties.c b/backend/drm/properties.c
index d78bfaf64bff9c1c4531dc82caf1a140689646f7..05af167389a07f704b70e493a01fd3dfe1193984 100644
--- a/backend/drm/properties.c
+++ b/backend/drm/properties.c
@@ -40,6 +40,7 @@ static const struct prop_info crtc_info[] = {
 	{ "GAMMA_LUT", INDEX(gamma_lut) },
 	{ "GAMMA_LUT_SIZE", INDEX(gamma_lut_size) },
 	{ "MODE_ID", INDEX(mode_id) },
+	{ "OUT_FENCE_PTR", INDEX(out_fence_ptr) },
 	{ "VRR_ENABLED", INDEX(vrr_enabled) },
 #undef INDEX
 };
@@ -55,6 +56,7 @@ static const struct prop_info plane_info[] = {
 	{ "FB_ID", INDEX(fb_id) },
 	{ "HOTSPOT_X", INDEX(hotspot_x) },
 	{ "HOTSPOT_Y", INDEX(hotspot_y) },
+	{ "IN_FENCE_FD", INDEX(in_fence_fd) },
 	{ "IN_FORMATS", INDEX(in_formats) },
 	{ "SIZE_HINTS", INDEX(size_hints) },
 	{ "SRC_H", INDEX(src_h) },
diff --git a/docs/env_vars.md b/docs/env_vars.md
index a2a86c84dded4367f398cd0c099378fc2c2c9e23..06e47ac5998fbd53b7c0cd9bda18c6e59e38bef8 100644
--- a/docs/env_vars.md
+++ b/docs/env_vars.md
@@ -12,6 +12,8 @@ wlroots reads these environment variables
   renderers: gles2, pixman, vulkan)
 * *WLR_RENDER_DRM_DEVICE*: specifies the DRM node to use for
   hardware-accelerated renderers.
+* *WLR_RENDER_NO_EXPLICIT_SYNC*: set to 1 to disable explicit synchronization
+  support in renderers.
 * *WLR_EGL_NO_MODIFIERS*: set to 1 to disable format modifiers in EGL, this can
   be used to understand and work around driver bugs.
 
diff --git a/include/backend/drm/drm.h b/include/backend/drm/drm.h
index 1106e9f56da0250fc31a4f11d61c56b7bf08a57f..18f4874202c3b49e094addc41201c3f1b2933dca 100644
--- a/include/backend/drm/drm.h
+++ b/include/backend/drm/drm.h
@@ -145,6 +145,7 @@ struct wlr_drm_connector_state {
 	uint32_t mode_id;
 	uint32_t gamma_lut;
 	uint32_t fb_damage_clips;
+	int primary_in_fence_fd, out_fence_fd;
 	bool vrr_enabled;
 };
 
diff --git a/include/backend/drm/properties.h b/include/backend/drm/properties.h
index 57073702189246c9aef418974e034b420ab72c95..421eb42755b2c9275b29667cdb9baae1da504481 100644
--- a/include/backend/drm/properties.h
+++ b/include/backend/drm/properties.h
@@ -38,6 +38,7 @@ struct wlr_drm_crtc_props {
 
 	uint32_t active;
 	uint32_t mode_id;
+	uint32_t out_fence_ptr;
 };
 
 struct wlr_drm_plane_props {
@@ -61,6 +62,7 @@ struct wlr_drm_plane_props {
 	uint32_t fb_damage_clips;
 	uint32_t hotspot_x;
 	uint32_t hotspot_y;
+	uint32_t in_fence_fd;
 };
 
 bool get_drm_connector_props(int fd, uint32_t id,
diff --git a/include/render/egl.h b/include/render/egl.h
index 0765cce749081f9724e7f383b461214e878502b9..103ab57df73e2e939a90968f91a61e7c67ad5da7 100644
--- a/include/render/egl.h
+++ b/include/render/egl.h
@@ -38,6 +38,10 @@ struct wlr_egl {
 		PFNEGLQUERYDISPLAYATTRIBEXTPROC eglQueryDisplayAttribEXT;
 		PFNEGLQUERYDEVICESTRINGEXTPROC eglQueryDeviceStringEXT;
 		PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT;
+		PFNEGLCREATESYNCKHRPROC eglCreateSyncKHR;
+		PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR;
+		PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
+		PFNEGLWAITSYNCKHRPROC eglWaitSyncKHR;
 	} procs;
 
 	bool has_modifiers;
@@ -105,4 +109,12 @@ bool wlr_egl_make_current(struct wlr_egl *egl, struct wlr_egl_context *save_cont
 
 bool wlr_egl_unset_current(struct wlr_egl *egl);
 
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd);
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync);
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
 #endif
diff --git a/include/render/gles2.h b/include/render/gles2.h
index a472ee9c60928029d35b095763ef62671a73b383..0f24ae38e56956aa90a6bbfb1dcca2313713d435 100644
--- a/include/render/gles2.h
+++ b/include/render/gles2.h
@@ -138,6 +138,8 @@ struct wlr_gles2_render_pass {
 	float projection_matrix[9];
 	struct wlr_egl_context prev_ctx;
 	struct wlr_gles2_render_timer *timer;
+	struct wlr_drm_syncobj_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 bool is_gles2_pixel_format_supported(const struct wlr_gles2_renderer *renderer,
@@ -169,6 +171,7 @@ void push_gles2_debug_(struct wlr_gles2_renderer *renderer,
 void pop_gles2_debug(struct wlr_gles2_renderer *renderer);
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer);
+	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+	struct wlr_drm_syncobj_timeline *signal_timeline, uint64_t signal_point);
 
 #endif
diff --git a/include/types/wlr_output.h b/include/types/wlr_output.h
index 09be35510818c8ea39137a50f0865530d0b69f02..bd095d8f20251f8b543483f2b7dff5244a52281b 100644
--- a/include/types/wlr_output.h
+++ b/include/types/wlr_output.h
@@ -18,7 +18,8 @@ bool output_ensure_buffer(struct wlr_output *output,
 bool output_cursor_set_texture(struct wlr_output_cursor *cursor,
 	struct wlr_texture *texture, bool own_texture, const struct wlr_fbox *src_box,
 	int dst_width, int dst_height, enum wl_output_transform transform,
-	int32_t hotspot_x, int32_t hotspot_y);
+	int32_t hotspot_x, int32_t hotspot_y, struct wlr_drm_syncobj_timeline *wait_timeline,
+	uint64_t wait_point);
 
 void output_defer_present(struct wlr_output *output, struct wlr_output_event_present event);
 
diff --git a/include/wlr/render/drm_syncobj.h b/include/wlr/render/drm_syncobj.h
index be3dce2d7652c4a2237b084375d9d8ff932312e2..bf406d8716554cc519e7dcc4a5e356c654fe6cc7 100644
--- a/include/wlr/render/drm_syncobj.h
+++ b/include/wlr/render/drm_syncobj.h
@@ -62,6 +62,17 @@ struct wlr_drm_syncobj_timeline *wlr_drm_syncobj_timeline_ref(struct wlr_drm_syn
  * Unreference a synchronization timeline.
  */
 void wlr_drm_syncobj_timeline_unref(struct wlr_drm_syncobj_timeline *timeline);
+/**
+ * Export a drm_syncobj FD from a timeline.
+ */
+int wlr_drm_syncobj_timeline_export(struct wlr_drm_syncobj_timeline *timeline);
+/**
+ * Transfer a point from a timeline to another.
+ *
+ * Both timelines must have been created with the same DRM FD.
+ */
+bool wlr_drm_syncobj_timeline_transfer(struct wlr_drm_syncobj_timeline *dst,
+	uint64_t dst_point, struct wlr_drm_syncobj_timeline *src, uint64_t src_point);
 /**
  * Check if a timeline point has been signalled or has materialized.
  *
diff --git a/include/wlr/render/pass.h b/include/wlr/render/pass.h
index 66480f7f7d05e859118fd2f7219a6d7de808b2ec..2159bc3df74a9bebe79ee7c5c9c99410cc097df0 100644
--- a/include/wlr/render/pass.h
+++ b/include/wlr/render/pass.h
@@ -33,6 +33,17 @@ struct wlr_buffer_pass_options {
 	/* Color transform to apply to the output of the render pass,
 	 * leave NULL to indicate sRGB/no custom transform */
 	struct wlr_color_transform *color_transform;
+
+	/* Signal a timeline synchronization point when the render pass completes.
+	 *
+	 * When a compositor provides a signal timeline, the renderer may skip
+	 * implicit signal synchronization.
+	 *
+	 * Support for this feature is advertised by features.timeline in
+	 * struct wlr_renderer.
+	 */
+	struct wlr_drm_syncobj_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 /**
@@ -88,6 +99,17 @@ struct wlr_render_texture_options {
 	enum wlr_scale_filter_mode filter_mode;
 	/* Blend mode */
 	enum wlr_render_blend_mode blend_mode;
+
+	/* Wait for a timeline synchronization point before texturing.
+	 *
+	 * When a compositor provides a wait timeline, the renderer may skip
+	 * implicit wait synchronization.
+	 *
+	 * Support for this feature is advertised by features.timeline in
+	 * struct wlr_renderer.
+	 */
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
 };
 
 /**
diff --git a/include/wlr/render/wlr_renderer.h b/include/wlr/render/wlr_renderer.h
index bb9a55fcf6d654a31913e913929ab009521fd835..4a8ccd3981572f075f02a2ef15229b042f75a3a8 100644
--- a/include/wlr/render/wlr_renderer.h
+++ b/include/wlr/render/wlr_renderer.h
@@ -45,6 +45,12 @@ struct wlr_renderer {
 		 * Does the renderer support color transforms on its output?
 		 */
 		bool output_color_transform;
+		/**
+		 * Whether wait/signal timelines are supported.
+		 *
+		 * See struct wlr_drm_syncobj_timeline.
+		 */
+		bool timeline;
 	} features;
 
 	// private state
diff --git a/include/wlr/types/wlr_linux_drm_syncobj_v1.h b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
index c6e0617b1cbec77a93eebf119c4c992a868c1f09..1a29a0d8f1522bd3e74f9f84bf072c5bd1b1fb06 100644
--- a/include/wlr/types/wlr_linux_drm_syncobj_v1.h
+++ b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
@@ -43,4 +43,13 @@ struct wlr_linux_drm_syncobj_manager_v1 *wlr_linux_drm_syncobj_manager_v1_create
 struct wlr_linux_drm_syncobj_surface_v1_state *wlr_linux_drm_syncobj_v1_get_surface_state(
 	struct wlr_surface *surface);
 
+/**
+ * Signal the release point when wlr_buffer.events.release is emitted.
+ *
+ * Compositors unwilling to track fine-grained commit release can call this
+ * helper on surface commit.
+ */
+bool wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(
+	struct wlr_linux_drm_syncobj_surface_v1_state *state, struct wlr_buffer *buffer);
+
 #endif
diff --git a/include/wlr/types/wlr_output.h b/include/wlr/types/wlr_output.h
index ead4703966b05e821fb7bb4a0257ec053d3fff02..f32e15ef59b58a0aba696dbf5470f574f6df9adf 100644
--- a/include/wlr/types/wlr_output.h
+++ b/include/wlr/types/wlr_output.h
@@ -45,6 +45,8 @@ struct wlr_output_cursor {
 	int32_t hotspot_x, hotspot_y;
 	struct wlr_texture *texture;
 	bool own_texture;
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
 	struct wl_listener renderer_destroy;
 	struct wl_list link;
 };
@@ -66,6 +68,8 @@ enum wlr_output_state_field {
 	WLR_OUTPUT_STATE_RENDER_FORMAT = 1 << 8,
 	WLR_OUTPUT_STATE_SUBPIXEL = 1 << 9,
 	WLR_OUTPUT_STATE_LAYERS = 1 << 10,
+	WLR_OUTPUT_STATE_WAIT_TIMELINE = 1 << 11,
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE = 1 << 12,
 };
 
 enum wlr_output_state_mode_type {
@@ -109,6 +113,11 @@ struct wlr_output_state {
 
 	struct wlr_output_layer_state *layers;
 	size_t layers_len;
+
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
+	struct wlr_drm_syncobj_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 struct wlr_output_impl;
@@ -162,6 +171,8 @@ struct wlr_output {
 
 	// true for example with VR headsets
 	bool non_desktop;
+	// Whether wait/signal timelines are supported
+	bool timeline;
 
 	// Commit sequence number. Incremented on each commit, may overflow.
 	uint32_t commit_seq;
@@ -536,6 +547,33 @@ void wlr_output_state_set_damage(struct wlr_output_state *state,
  */
 void wlr_output_state_set_layers(struct wlr_output_state *state,
 	struct wlr_output_layer_state *layers, size_t layers_len);
+/**
+ * Set a timeline point to wait on before displaying the next frame.
+ *
+ * Committing a wait timeline point without a buffer is invalid.
+ *
+ * There is only a single wait timeline point, waiting for multiple timeline
+ * points is unsupported.
+ *
+ * Support for this feature is advertised by the timeline field in
+ * struct wlr_output.
+ */
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+	struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point);
+/**
+ * Set a timeline point to be signalled when the frame is no longer being used
+ * by the backend.
+ *
+ * Committing a signal timeline point without a buffer is invalid.
+ *
+ * There is only a single signal timeline point, signalling multiple timeline
+ * points is unsupported.
+ *
+ * Support for this feature is advertised by the timeline field in
+ * struct wlr_output.
+ */
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+	struct wlr_drm_syncobj_timeline *timeline, uint64_t dst_point);
 
 /**
  * Copies the output state from src to dst. It is safe to then
diff --git a/include/wlr/types/wlr_scene.h b/include/wlr/types/wlr_scene.h
index d1fbca7de4928c0466055d1f14e04219e3639749..b92e63d44ae616830d710267296cc2efa0ed58e4 100644
--- a/include/wlr/types/wlr_scene.h
+++ b/include/wlr/types/wlr_scene.h
@@ -191,6 +191,9 @@ struct wlr_scene_buffer {
 	int buffer_width, buffer_height;
 	bool buffer_is_opaque;
 
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
+
 	struct wl_listener buffer_release;
 	struct wl_listener renderer_destroy;
 };
@@ -224,6 +227,9 @@ struct wlr_scene_output {
 	struct wl_list damage_highlight_regions;
 
 	struct wl_array render_list;
+
+	struct wlr_drm_syncobj_timeline *in_timeline;
+	uint64_t in_point;
 };
 
 struct wlr_scene_timer {
@@ -454,6 +460,9 @@ void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer,
 void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer,
 	struct timespec *now);
 
+void wlr_scene_buffer_set_wait_timeline(struct wlr_scene_buffer *scene_buffer,
+	struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point);
+
 /**
  * Add a viewport for the specified output to the scene-graph.
  *
diff --git a/render/drm_syncobj.c b/render/drm_syncobj.c
index af3e79fcda7b8684663ffb9009f64443509d3fbb..f7120df309eb0c793f86dc498c85af03169fadad 100644
--- a/render/drm_syncobj.c
+++ b/render/drm_syncobj.c
@@ -67,6 +67,28 @@ void wlr_drm_syncobj_timeline_unref(struct wlr_drm_syncobj_timeline *timeline) {
 	free(timeline);
 }
 
+int wlr_drm_syncobj_timeline_export(struct wlr_drm_syncobj_timeline *timeline) {
+	int drm_syncobj_fd = -1;
+	if (drmSyncobjHandleToFD(timeline->drm_fd, timeline->handle, &drm_syncobj_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjHandleToFD failed");
+		return -1;
+	}
+	return drm_syncobj_fd;
+}
+
+bool wlr_drm_syncobj_timeline_transfer(struct wlr_drm_syncobj_timeline *dst,
+		uint64_t dst_point, struct wlr_drm_syncobj_timeline *src, uint64_t src_point) {
+	assert(dst->drm_fd == src->drm_fd);
+
+	if (drmSyncobjTransfer(dst->drm_fd, dst->handle, dst_point,
+			src->handle, src_point, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		return false;
+	}
+
+	return true;
+}
+
 int wlr_drm_syncobj_timeline_export_sync_file(struct wlr_drm_syncobj_timeline *timeline,
 		uint64_t src_point) {
 	int sync_file_fd = -1;
diff --git a/render/egl.c b/render/egl.c
index 19868ca84e95eb1e122f149b3f7fdf1396752da8..ce0c95d914e7f6a115b94680cba554606dc90a45 100644
--- a/render/egl.c
+++ b/render/egl.c
@@ -348,6 +348,18 @@ static bool egl_init_display(struct wlr_egl *egl, EGLDisplay display) {
 		return false;
 	}
 
+	if (check_egl_ext(display_exts_str, "EGL_KHR_fence_sync") &&
+			check_egl_ext(display_exts_str, "EGL_ANDROID_native_fence_sync")) {
+		load_egl_proc(&egl->procs.eglCreateSyncKHR, "eglCreateSyncKHR");
+		load_egl_proc(&egl->procs.eglDestroySyncKHR, "eglDestroySyncKHR");
+		load_egl_proc(&egl->procs.eglDupNativeFenceFDANDROID,
+			"eglDupNativeFenceFDANDROID");
+	}
+
+	if (check_egl_ext(display_exts_str, "EGL_KHR_wait_sync")) {
+		load_egl_proc(&egl->procs.eglWaitSyncKHR, "eglWaitSyncKHR");
+	}
+
 	egl->exts.IMG_context_priority =
 		check_egl_ext(display_exts_str, "EGL_IMG_context_priority");
 
@@ -1014,3 +1026,65 @@ int wlr_egl_dup_drm_fd(struct wlr_egl *egl) {
 	}
 	return fd;
 }
+
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd) {
+	if (!egl->procs.eglCreateSyncKHR) {
+		return EGL_NO_SYNC_KHR;
+	}
+
+	EGLint attribs[3] = { EGL_NONE };
+	int dup_fd = -1;
+	if (fence_fd >= 0) {
+		dup_fd = fcntl(fence_fd, F_DUPFD_CLOEXEC, 0);
+		if (dup_fd < 0) {
+			wlr_log_errno(WLR_ERROR, "dup failed");
+			return EGL_NO_SYNC_KHR;
+		}
+
+		attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+		attribs[1] = dup_fd;
+		attribs[2] = EGL_NONE;
+	}
+
+	EGLSyncKHR sync = egl->procs.eglCreateSyncKHR(egl->display,
+		EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+	if (sync == EGL_NO_SYNC_KHR) {
+		wlr_log(WLR_ERROR, "eglCreateSyncKHR failed");
+		if (dup_fd >= 0) {
+			close(dup_fd);
+		}
+	}
+	return sync;
+}
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (sync == EGL_NO_SYNC_KHR) {
+		return;
+	}
+	assert(egl->procs.eglDestroySyncKHR);
+	if (egl->procs.eglDestroySyncKHR(egl->display, sync) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglDestroySyncKHR failed");
+	}
+}
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (!egl->procs.eglDupNativeFenceFDANDROID) {
+		return -1;
+	}
+
+	int fd = egl->procs.eglDupNativeFenceFDANDROID(egl->display, sync);
+	if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+		wlr_log(WLR_ERROR, "eglDupNativeFenceFDANDROID failed");
+		return -1;
+	}
+
+	return fd;
+}
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (egl->procs.eglWaitSyncKHR(egl->display, sync, 0) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglWaitSyncKHR failed");
+		return false;
+	}
+	return true;
+}
diff --git a/render/gles2/pass.c b/render/gles2/pass.c
index 9177b0a1fafb9269bfaa44caa466e4f6ede57531..2942ab587d24d216c2cd7b0f57b4ed5346ac8570 100644
--- a/render/gles2/pass.c
+++ b/render/gles2/pass.c
@@ -2,8 +2,11 @@
 #include <assert.h>
 #include <pixman.h>
 #include <time.h>
+#include <unistd.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/util/transform.h>
+#include "render/egl.h"
 #include "render/gles2.h"
 #include "types/wlr_matrix.h"
 
@@ -21,6 +24,7 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 	struct wlr_gles2_render_pass *pass = get_render_pass(wlr_pass);
 	struct wlr_gles2_renderer *renderer = pass->buffer->renderer;
 	struct wlr_gles2_render_timer *timer = pass->timer;
+	bool ok = false;
 
 	push_gles2_debug(renderer);
 
@@ -36,16 +40,40 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 		clock_gettime(CLOCK_MONOTONIC, &timer->cpu_end);
 	}
 
-	glFlush();
+	if (pass->signal_timeline != NULL) {
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, -1);
+		if (sync == EGL_NO_SYNC_KHR) {
+			goto out;
+		}
+
+		int sync_file_fd = wlr_egl_dup_fence_fd(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (sync_file_fd < 0) {
+			goto out;
+		}
+
+		bool ok = wlr_drm_syncobj_timeline_import_sync_file(pass->signal_timeline, pass->signal_point, sync_file_fd);
+		close(sync_file_fd);
+		if (!ok) {
+			goto out;
+		}
+	} else {
+		glFlush();
+	}
+
+	ok = true;
+
+out:
 	glBindFramebuffer(GL_FRAMEBUFFER, 0);
 
 	pop_gles2_debug(renderer);
 	wlr_egl_restore_context(&pass->prev_ctx);
 
+	wlr_drm_syncobj_timeline_unref(pass->signal_timeline);
 	wlr_buffer_unlock(pass->buffer->buffer);
 	free(pass);
 
-	return true;
+	return ok;
 }
 
 static void render(const struct wlr_box *box, const pixman_region32_t *clip, GLint attrib) {
@@ -175,6 +203,27 @@ static void render_pass_add_texture(struct wlr_render_pass *wlr_pass,
 	src_fbox.height /= options->texture->height;
 
 	push_gles2_debug(renderer);
+
+	if (options->wait_timeline != NULL) {
+		int sync_file_fd =
+			wlr_drm_syncobj_timeline_export_sync_file(options->wait_timeline, options->wait_point);
+		if (sync_file_fd < 0) {
+			return;
+		}
+
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, sync_file_fd);
+		close(sync_file_fd);
+		if (sync == EGL_NO_SYNC_KHR) {
+			return;
+		}
+
+		bool ok = wlr_egl_wait_sync(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (!ok) {
+			return;
+		}
+	}
+
 	setup_blending(!texture->has_alpha && alpha == 1.0 ?
 		WLR_RENDER_BLEND_MODE_NONE : options->blend_mode);
 
@@ -247,7 +296,8 @@ static const char *reset_status_str(GLenum status) {
 }
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer) {
+		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+		struct wlr_drm_syncobj_timeline *signal_timeline, uint64_t signal_point) {
 	struct wlr_gles2_renderer *renderer = buffer->renderer;
 	struct wlr_buffer *wlr_buffer = buffer->buffer;
 
@@ -275,6 +325,10 @@ struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *b
 	pass->buffer = buffer;
 	pass->timer = timer;
 	pass->prev_ctx = *prev_ctx;
+	if (signal_timeline != NULL) {
+		pass->signal_timeline = wlr_drm_syncobj_timeline_ref(signal_timeline);
+		pass->signal_point = signal_point;
+	}
 
 	matrix_projection(pass->projection_matrix, wlr_buffer->width, wlr_buffer->height,
 		WL_OUTPUT_TRANSFORM_FLIPPED_180);
diff --git a/render/gles2/renderer.c b/render/gles2/renderer.c
index 4694b2a8f8aa4151c305a976222f10227611b20d..3eeb1ba9c199ddd7a26ead06ba502efb5a0622cd 100644
--- a/render/gles2/renderer.c
+++ b/render/gles2/renderer.c
@@ -259,7 +259,8 @@ static struct wlr_render_pass *gles2_begin_buffer_pass(struct wlr_renderer *wlr_
 		return NULL;
 	}
 
-	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer, &prev_ctx, timer);
+	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer,
+		&prev_ctx, timer, options->signal_timeline, options->signal_point);
 	if (!pass) {
 		return NULL;
 	}
@@ -683,6 +684,9 @@ struct wlr_renderer *wlr_gles2_renderer_create(struct wlr_egl *egl) {
 
 	get_gles2_shm_formats(renderer, &renderer->shm_texture_formats);
 
+	renderer->wlr_renderer.features.timeline =
+		egl->procs.eglDupNativeFenceFDANDROID && egl->procs.eglWaitSyncKHR;
+
 	return &renderer->wlr_renderer;
 
 error:
diff --git a/render/wlr_renderer.c b/render/wlr_renderer.c
index 6a28908c4809cc1c255f4c3683ddab17eea08bff..a580ab56de52c7a0e25c1c95304c0b8898921cc1 100644
--- a/render/wlr_renderer.c
+++ b/render/wlr_renderer.c
@@ -274,6 +274,9 @@ out:
 	if (own_drm_fd && drm_fd >= 0) {
 		close(drm_fd);
 	}
+	if (renderer != NULL && env_parse_bool("WLR_RENDER_NO_EXPLICIT_SYNC")) {
+		renderer->features.timeline = false;
+	}
 	return renderer;
 }
 
diff --git a/types/output/cursor.c b/types/output/cursor.c
index 2bf78528374ec6b45b86d93d60b85981f1225868..95793a39d1421c9851cc98ccdc2ec7c002666013 100644
--- a/types/output/cursor.c
+++ b/types/output/cursor.c
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <wlr/interfaces/wlr_output.h>
 #include <wlr/render/swapchain.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/util/log.h>
@@ -271,6 +272,8 @@ static struct wlr_buffer *render_cursor_buffer(struct wlr_output_cursor *cursor)
 		.src_box = cursor->src_box,
 		.dst_box = dst_box,
 		.transform = transform,
+		.wait_timeline = cursor->wait_timeline,
+		.wait_point = cursor->wait_point,
 	});
 
 	if (!wlr_render_pass_submit(pass)) {
@@ -355,20 +358,22 @@ bool wlr_output_cursor_set_buffer(struct wlr_output_cursor *cursor,
 	hotspot_y /= cursor->output->scale;
 
 	return output_cursor_set_texture(cursor, texture, true, &src_box,
-		dst_width, dst_height, WL_OUTPUT_TRANSFORM_NORMAL, hotspot_x, hotspot_y);
+		dst_width, dst_height, WL_OUTPUT_TRANSFORM_NORMAL, hotspot_x, hotspot_y,
+		NULL, 0);
 }
 
 static void output_cursor_handle_renderer_destroy(struct wl_listener *listener,
 		void *data) {
 	struct wlr_output_cursor *cursor = wl_container_of(listener, cursor, renderer_destroy);
 	output_cursor_set_texture(cursor, NULL, false, NULL, 0, 0,
-		WL_OUTPUT_TRANSFORM_NORMAL, 0, 0);
+		WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, NULL, 0);
 }
 
 bool output_cursor_set_texture(struct wlr_output_cursor *cursor,
 		struct wlr_texture *texture, bool own_texture, const struct wlr_fbox *src_box,
 		int dst_width, int dst_height, enum wl_output_transform transform,
-		int32_t hotspot_x, int32_t hotspot_y) {
+		int32_t hotspot_x, int32_t hotspot_y,
+		struct wlr_drm_syncobj_timeline *wait_timeline, uint64_t wait_point) {
 	struct wlr_output *output = cursor->output;
 
 	output_cursor_reset(cursor);
@@ -395,6 +400,15 @@ bool output_cursor_set_texture(struct wlr_output_cursor *cursor,
 	cursor->texture = texture;
 	cursor->own_texture = own_texture;
 
+	wlr_drm_syncobj_timeline_unref(cursor->wait_timeline);
+	if (wait_timeline != NULL) {
+		cursor->wait_timeline = wlr_drm_syncobj_timeline_ref(wait_timeline);
+		cursor->wait_point = wait_point;
+	} else {
+		cursor->wait_timeline = NULL;
+		cursor->wait_point = 0;
+	}
+
 	wl_list_remove(&cursor->renderer_destroy.link);
 	if (texture != NULL) {
 		cursor->renderer_destroy.notify = output_cursor_handle_renderer_destroy;
@@ -471,6 +485,7 @@ void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor) {
 	if (cursor->own_texture) {
 		wlr_texture_destroy(cursor->texture);
 	}
+	wlr_drm_syncobj_timeline_unref(cursor->wait_timeline);
 	wl_list_remove(&cursor->link);
 	free(cursor);
 }
diff --git a/types/output/output.c b/types/output/output.c
index 818f4549e9245968a4f6093eb3165bee5a493e45..1c9a007796aa4906d2f61c820a4e0ac5453bcf21 100644
--- a/types/output/output.c
+++ b/types/output/output.c
@@ -563,9 +563,19 @@ static bool output_basic_test(struct wlr_output *output,
 			wlr_log(WLR_DEBUG, "Primary buffer size mismatch");
 			return false;
 		}
-	} else if (state->tearing_page_flip) {
-		wlr_log(WLR_ERROR, "Trying to commit a tearing page flip without a buffer?");
-		return false;
+	} else {
+		if (state->tearing_page_flip) {
+			wlr_log(WLR_ERROR, "Tried to commit a tearing page flip without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set wait timeline without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set signal timeline without a buffer");
+			return false;
+		}
 	}
 
 	if (state->committed & WLR_OUTPUT_STATE_RENDER_FORMAT) {
@@ -632,6 +642,12 @@ static bool output_basic_test(struct wlr_output *output,
 		}
 	}
 
+	if ((state->committed & (WLR_OUTPUT_STATE_WAIT_TIMELINE | WLR_OUTPUT_STATE_SIGNAL_TIMELINE)) &&
+			!output->timeline) {
+		wlr_log(WLR_DEBUG, "Wait/signal timelines are not supported for this output");
+		return false;
+	}
+
 	return true;
 }
 
diff --git a/types/output/state.c b/types/output/state.c
index 0909b3e8ac15927c2e94c9c80028dee16fcadaf6..465b54adac05d40195101eaf253ffa88de79e3ce 100644
--- a/types/output/state.c
+++ b/types/output/state.c
@@ -1,5 +1,6 @@
 #include <stdlib.h>
 #include <string.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/util/log.h>
 #include "types/wlr_output.h"
 
@@ -16,6 +17,8 @@ void wlr_output_state_finish(struct wlr_output_state *state) {
 	state->buffer = NULL;
 	pixman_region32_fini(&state->damage);
 	free(state->gamma_lut);
+	wlr_drm_syncobj_timeline_unref(state->wait_timeline);
+	wlr_drm_syncobj_timeline_unref(state->signal_timeline);
 }
 
 void wlr_output_state_set_enabled(struct wlr_output_state *state,
@@ -114,16 +117,36 @@ void wlr_output_state_set_layers(struct wlr_output_state *state,
 	state->layers_len = layers_len;
 }
 
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+		struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point) {
+	state->committed |= WLR_OUTPUT_STATE_WAIT_TIMELINE;
+	wlr_drm_syncobj_timeline_unref(state->wait_timeline);
+	state->wait_timeline = wlr_drm_syncobj_timeline_ref(timeline);
+	state->wait_point = src_point;
+}
+
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+		struct wlr_drm_syncobj_timeline *timeline, uint64_t dst_point) {
+	state->committed |= WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
+	wlr_drm_syncobj_timeline_unref(state->signal_timeline);
+	state->signal_timeline = wlr_drm_syncobj_timeline_ref(timeline);
+	state->signal_point = dst_point;
+}
+
 bool wlr_output_state_copy(struct wlr_output_state *dst,
 		const struct wlr_output_state *src) {
 	struct wlr_output_state copy = *src;
 	copy.committed &= ~(WLR_OUTPUT_STATE_BUFFER |
 		WLR_OUTPUT_STATE_DAMAGE |
-		WLR_OUTPUT_STATE_GAMMA_LUT);
+		WLR_OUTPUT_STATE_GAMMA_LUT |
+		WLR_OUTPUT_STATE_WAIT_TIMELINE |
+		WLR_OUTPUT_STATE_SIGNAL_TIMELINE);
 	copy.buffer = NULL;
 	pixman_region32_init(&copy.damage);
 	copy.gamma_lut = NULL;
 	copy.gamma_lut_size = 0;
+	copy.wait_timeline = NULL;
+	copy.signal_timeline = NULL;
 
 	if (src->committed & WLR_OUTPUT_STATE_BUFFER) {
 		wlr_output_state_set_buffer(&copy, src->buffer);
@@ -142,6 +165,15 @@ bool wlr_output_state_copy(struct wlr_output_state *dst,
 		}
 	}
 
+	if (src->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+		wlr_output_state_set_wait_timeline(&copy, src->wait_timeline,
+			src->wait_point);
+	}
+	if (src->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+		wlr_output_state_set_signal_timeline(&copy, src->signal_timeline,
+			src->signal_point);
+	}
+
 	wlr_output_state_finish(dst);
 	*dst = copy;
 	return true;
diff --git a/types/scene/surface.c b/types/scene/surface.c
index 1905b4dfb5ac74cd482e180ef16ad4ece4e8efc3..91a7a95fd6cf741a9f1cc6efdf9cc63d8397d62d 100644
--- a/types/scene/surface.c
+++ b/types/scene/surface.c
@@ -4,6 +4,7 @@
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/util/transform.h>
 #include "types/wlr_scene.h"
@@ -142,6 +143,7 @@ static void surface_reconfigure(struct wlr_scene_surface *scene_surface) {
 
 	if (width <= 0 || height <= 0) {
 		wlr_scene_buffer_set_buffer(scene_buffer, NULL);
+		wlr_scene_buffer_set_wait_timeline(scene_buffer, NULL, 0);
 		pixman_region32_fini(&opaque);
 		return;
 	}
@@ -171,6 +173,22 @@ static void surface_reconfigure(struct wlr_scene_surface *scene_surface) {
 	}
 
 	pixman_region32_fini(&opaque);
+
+	struct wlr_drm_syncobj_timeline *wait_timeline = NULL;
+	uint64_t wait_point = 0;
+	struct wlr_linux_drm_syncobj_surface_v1_state *syncobj_surface_state =
+		wlr_linux_drm_syncobj_v1_get_surface_state(surface);
+	if (syncobj_surface_state != NULL) {
+		wait_timeline = syncobj_surface_state->acquire_timeline;
+		wait_point = syncobj_surface_state->acquire_point;
+	}
+	wlr_scene_buffer_set_wait_timeline(scene_buffer, wait_timeline, wait_point);
+
+	if (syncobj_surface_state != NULL && surface->buffer != NULL &&
+			(surface->current.committed & WLR_SURFACE_STATE_BUFFER)) {
+		wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(syncobj_surface_state,
+			&surface->buffer->base);
+	}
 }
 
 static void handle_scene_surface_surface_commit(
diff --git a/types/scene/wlr_scene.c b/types/scene/wlr_scene.c
index 46768aabe174288b0fb211d10e1d5032bc0dadbc..e0af6f72789fcf9b4e5ec976d20b5d87bb1d6bf7 100644
--- a/types/scene/wlr_scene.c
+++ b/types/scene/wlr_scene.c
@@ -3,6 +3,7 @@
 #include <string.h>
 #include <wlr/backend.h>
 #include <wlr/render/swapchain.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_damage_ring.h>
@@ -117,6 +118,7 @@ void wlr_scene_node_destroy(struct wlr_scene_node *node) {
 		scene_buffer_set_buffer(scene_buffer, NULL);
 		scene_buffer_set_texture(scene_buffer, NULL);
 		pixman_region32_fini(&scene_buffer->opaque_region);
+		wlr_drm_syncobj_timeline_unref(scene_buffer->wait_timeline);
 	} else if (node->type == WLR_SCENE_NODE_TREE) {
 		struct wlr_scene_tree *scene_tree = wlr_scene_tree_from_node(node);
 
@@ -898,6 +900,18 @@ void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer,
 	scene_node_update(&scene_buffer->node, NULL);
 }
 
+void wlr_scene_buffer_set_wait_timeline(struct wlr_scene_buffer *scene_buffer,
+		struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point) {
+	wlr_drm_syncobj_timeline_unref(scene_buffer->wait_timeline);
+	if (timeline != NULL) {
+		scene_buffer->wait_timeline = wlr_drm_syncobj_timeline_ref(timeline);
+		scene_buffer->wait_point = src_point;
+	} else {
+		scene_buffer->wait_timeline = NULL;
+		scene_buffer->wait_point = 0;
+	}
+}
+
 static struct wlr_texture *scene_buffer_get_texture(
 		struct wlr_scene_buffer *scene_buffer, struct wlr_renderer *renderer) {
 	if (scene_buffer->buffer == NULL || scene_buffer->texture != NULL) {
@@ -1244,6 +1258,8 @@ static void scene_entry_render(struct render_list_entry *entry, const struct ren
 			.filter_mode = scene_buffer->filter_mode,
 			.blend_mode = pixman_region32_not_empty(&opaque) ?
 				WLR_RENDER_BLEND_MODE_PREMULTIPLIED : WLR_RENDER_BLEND_MODE_NONE,
+			.wait_timeline = scene_buffer->wait_timeline,
+			.wait_point = scene_buffer->wait_point,
 		});
 
 		struct wlr_scene_output_sample_event sample_event = {
@@ -1406,6 +1422,14 @@ struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene,
 		prev_output_link = &current_output->link;
 	}
 
+	int drm_fd = wlr_backend_get_drm_fd(output->backend);
+	if (drm_fd >= 0 && output->timeline && output->renderer != NULL && output->renderer->features.timeline) {
+		scene_output->in_timeline = wlr_drm_syncobj_timeline_create(drm_fd);
+		if (scene_output->in_timeline == NULL) {
+			return NULL;
+		}
+	}
+
 	scene_output->index = prev_output_index + 1;
 	assert(scene_output->index < 64);
 	wl_list_insert(prev_output_link, &scene_output->link);
@@ -1454,7 +1478,7 @@ void wlr_scene_output_destroy(struct wlr_scene_output *scene_output) {
 	wl_list_remove(&scene_output->output_commit.link);
 	wl_list_remove(&scene_output->output_damage.link);
 	wl_list_remove(&scene_output->output_needs_frame.link);
-
+	wlr_drm_syncobj_timeline_unref(scene_output->in_timeline);
 	wl_array_release(&scene_output->render_list);
 	free(scene_output);
 }
@@ -1672,6 +1696,9 @@ static bool scene_entry_try_direct_scanout(struct render_list_entry *entry,
 	}
 
 	wlr_output_state_set_buffer(&pending, buffer->buffer);
+	if (buffer->wait_timeline != NULL) {
+		wlr_output_state_set_wait_timeline(&pending, buffer->wait_timeline, buffer->wait_point);
+	}
 
 	if (!wlr_output_test_state(scene_output->output, &pending)) {
 		wlr_output_state_finish(&pending);
@@ -1883,10 +1910,13 @@ bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output,
 		timer->pre_render_duration = timespec_to_nsec(&duration);
 	}
 
+	scene_output->in_point++;
 	struct wlr_render_pass *render_pass = wlr_renderer_begin_buffer_pass(output->renderer, buffer,
 			&(struct wlr_buffer_pass_options){
 		.timer = timer ? timer->render_timer : NULL,
 		.color_transform = options->color_transform,
+		.signal_timeline = scene_output->in_timeline,
+		.signal_point = scene_output->in_point,
 	});
 	if (render_pass == NULL) {
 		wlr_buffer_unlock(buffer);
@@ -1993,6 +2023,11 @@ bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output,
 	wlr_output_state_set_buffer(state, buffer);
 	wlr_buffer_unlock(buffer);
 
+	if (scene_output->in_timeline != NULL) {
+		wlr_output_state_set_wait_timeline(state, scene_output->in_timeline,
+			scene_output->in_point);
+	}
+
 	return true;
 }
 
diff --git a/types/wlr_cursor.c b/types/wlr_cursor.c
index 77ab2fb708f22169ce3dfd12aca1726873d14ec8..a2489fbd115657d59451ea841e9261af1483c938 100644
--- a/types/wlr_cursor.c
+++ b/types/wlr_cursor.c
@@ -7,6 +7,7 @@
 #include <wlr/types/wlr_cursor.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
 #include <wlr/types/wlr_input_device.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_pointer.h>
@@ -534,7 +535,7 @@ static void cursor_output_cursor_update(struct wlr_cursor_output_cursor *output_
 
 		output_cursor_set_texture(output_cursor->output_cursor, texture, true,
 			&src_box, dst_width, dst_height, WL_OUTPUT_TRANSFORM_NORMAL,
-			hotspot_x, hotspot_y);
+			hotspot_x, hotspot_y, NULL, 0);
 	} else if (cur->state->surface != NULL) {
 		struct wlr_surface *surface = cur->state->surface;
 
@@ -547,9 +548,24 @@ static void cursor_output_cursor_update(struct wlr_cursor_output_cursor *output_
 		int dst_width = surface->current.width;
 		int dst_height = surface->current.height;
 
+		struct wlr_linux_drm_syncobj_surface_v1_state *syncobj_surface_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(surface);
+		struct wlr_drm_syncobj_timeline *wait_timeline = NULL;
+		uint64_t wait_point = 0;
+		if (syncobj_surface_state != NULL) {
+			wait_timeline = syncobj_surface_state->acquire_timeline;
+			wait_point = syncobj_surface_state->acquire_point;
+		}
+
 		output_cursor_set_texture(output_cursor->output_cursor, texture, false,
 			&src_box, dst_width, dst_height, surface->current.transform,
-			hotspot_x, hotspot_y);
+			hotspot_x, hotspot_y, wait_timeline, wait_point);
+
+		if (syncobj_surface_state != NULL && surface->buffer != NULL &&
+				(surface->current.committed & WLR_SURFACE_STATE_BUFFER)) {
+			wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(syncobj_surface_state,
+				&surface->buffer->base);
+		}
 
 		if (output_cursor->output_cursor->visible) {
 			wlr_surface_send_enter(surface, output);
diff --git a/types/wlr_linux_drm_syncobj_v1.c b/types/wlr_linux_drm_syncobj_v1.c
index 82ace2d78b037381107e37754da98a282432ea60..bc2c79dc70eea06b9cf13d7ddc2e2d6c276a3f99 100644
--- a/types/wlr_linux_drm_syncobj_v1.c
+++ b/types/wlr_linux_drm_syncobj_v1.c
@@ -467,3 +467,40 @@ wlr_linux_drm_syncobj_v1_get_surface_state(struct wlr_surface *wlr_surface) {
 	}
 	return &surface->current;
 }
+
+struct release_signaller {
+	struct wlr_drm_syncobj_timeline *timeline;
+	uint64_t point;
+	struct wl_listener buffer_release;
+};
+
+static void release_signaller_handle_buffer_release(struct wl_listener *listener, void *data) {
+	struct release_signaller *signaller = wl_container_of(listener, signaller, buffer_release);
+
+	if (drmSyncobjTimelineSignal(signaller->timeline->drm_fd, &signaller->timeline->handle,
+			&signaller->point, 1) != 0) {
+		wlr_log(WLR_ERROR, "drmSyncobjTimelineSignal() failed");
+	}
+
+	wlr_drm_syncobj_timeline_unref(signaller->timeline);
+	free(signaller);
+}
+
+bool wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(
+		struct wlr_linux_drm_syncobj_surface_v1_state *state, struct wlr_buffer *buffer) {
+	assert(buffer->n_locks > 0);
+	assert(state->release_timeline != NULL);
+
+	struct release_signaller *signaller = calloc(1, sizeof(*signaller));
+	if (signaller == NULL) {
+		return false;
+	}
+
+	signaller->timeline = wlr_drm_syncobj_timeline_ref(state->release_timeline);
+	signaller->point = state->release_point;
+
+	signaller->buffer_release.notify = release_signaller_handle_buffer_release;
+	wl_signal_add(&buffer->events.release, &signaller->buffer_release);
+
+	return true;
+}
-- 
2.46.0

