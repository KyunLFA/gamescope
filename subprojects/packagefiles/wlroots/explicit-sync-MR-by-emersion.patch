explicit-sync-v2 branch from emersion (https://gitlab.freedesktop.org/emersion/wlroots/-/tree/explicit-sync-v2?ref_type=heads)

commit 68691fcd7390bc538d7f11ffce85c48037b1bfe5
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 15:08:44 2024 +0200

    scene: add explicit synchronization for rendered buffers

commit 1a04a7d908581930e1633abcd83026642b5c4213
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 14:37:12 2024 +0200

    scene: handle linux-drm-syncobj-v1 acquire timeline

commit 0472ab3d0b7394ec37b6af6a87432e89cbb17422
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 14:32:30 2024 +0200

    scene: add wlr_scene_buffer_set_wait_timeline()

commit b37a44746da150a3a82a3347c61042171f895116
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 22:00:39 2021 +0200

    examples/explicit-sync: new example

commit 85f0e2ce67da4b7214e774b6a98c3614fa3d38b7
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Oct 21 15:02:31 2021 +0200

    linux-drm-syncobj-v1: new protocol implementation

    References: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/90

commit 3555f19076d8625bf606d42e3a0ba64fe34f9d84
Author: Simon Ser <contact@emersion.fr>
Date:   Tue Feb 27 18:38:12 2024 +0100

    render/timeline: add wlr_render_timeline_export()

commit 06c8f413dc1952a7657ce39018bc42ed5cbb7f5b
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 17:24:09 2023 +0200

    render/timeline: add wlr_render_timeline_wait()

    References: https://patchwork.freedesktop.org/patch/506761/

commit 7a7a7ee060339f1a24256c1eec5dc01fc17723c9
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Oct 21 15:23:20 2021 +0200

    render/timeline: add wlr_render_timeline_transfer()

commit 4aebbbb1b3b24f1eb6f77b3f1bf9149f96fab73b
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Oct 21 15:02:09 2021 +0200

    render/timeline: add wlr_render_timeline_import()

commit 96f0376fb5f4c09288d3c22953d15942251c74db
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 20:09:38 2021 +0200

    backend/drm: add support for explicit sync APIs

commit 1493c29dc32e3e1914963c30d435498df5989c8c
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 19:29:00 2021 +0200

    output: add explicit sync API

commit 3efa61500a48b5d99a86ed8fa7c131ed35872688
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 16:15:59 2023 +0200

    render/gles2: implement explicit sync API

commit 3a7d68ae329042b45bd8a6201a6e5577e57b9a6d
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Mar 16 17:24:25 2020 +0100

    render/egl: add support for explicit sync extensions

commit 0758cf3b220b6e078f8f9a92ee46ad0074021c96
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 10:53:12 2023 +0200

    render: add explicit sync API

commit 30ebde45629cdb837c041edbaec3b94c0ff770bf
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 18:47:46 2021 +0200

    render/timeline: introduce wlr_timeline

    wlr_timeline is a synchronization primitive based on drm_syncobj
    timelines. They are heavily inspired from Vulkan timeline
    semaphores [1].

    [1]: https://www.khronos.org/blog/vulkan-timeline-semaphores
---
 backend/drm/atomic.c                         |  62 ++-
 backend/drm/drm.c                            |  10 +-
 backend/drm/properties.c                     |   2 +
 examples/explicit-sync.c                     | 298 +++++++++++++
 examples/meson.build                         |   4 +
 include/backend/drm/drm.h                    |   1 +
 include/backend/drm/properties.h             |   2 +
 include/render/egl.h                         |  12 +
 include/render/gles2.h                       |   5 +-
 include/wlr/render/pass.h                    |  24 +
 include/wlr/render/timeline.h                |  99 +++++
 include/wlr/render/wlr_renderer.h            |   9 +
 include/wlr/types/wlr_linux_drm_syncobj_v1.h |  46 ++
 include/wlr/types/wlr_output.h               |  36 ++
 include/wlr/types/wlr_scene.h                |   9 +
 protocol/meson.build                         |   1 +
 render/egl.c                                 |  74 ++++
 render/gles2/pass.c                          |  58 ++-
 render/gles2/renderer.c                      |   6 +-
 render/meson.build                           |   3 +
 render/timeline.c                            | 230 ++++++++++
 types/meson.build                            |   1 +
 types/output/output.c                        |  22 +-
 types/output/state.c                         |  28 ++
 types/scene/surface.c                        |  12 +
 types/scene/wlr_scene.c                      |  32 +-
 types/wlr_linux_drm_syncobj_v1.c             | 443 +++++++++++++++++++
 27 files changed, 1517 insertions(+), 12 deletions(-)
 create mode 100644 examples/explicit-sync.c
 create mode 100644 include/wlr/render/timeline.h
 create mode 100644 include/wlr/types/wlr_linux_drm_syncobj_v1.h
 create mode 100644 render/timeline.c
 create mode 100644 types/wlr_linux_drm_syncobj_v1.c

diff --git a/backend/drm/atomic.c b/backend/drm/atomic.c
index 9defa7c64c2a62c97565e315c30666d7555425bb..e30a5f07a726c54dd79c355f12f98f65c1fd4b76 100644
--- a/backend/drm/atomic.c
+++ b/backend/drm/atomic.c
@@ -1,6 +1,8 @@
 #include <drm_fourcc.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
 #include <wlr/util/log.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
@@ -272,6 +274,15 @@ bool drm_atomic_connector_prepare(struct wlr_drm_connector_state *state, bool mo
 			state->primary_fb->wlr_buf->height, &state->base->damage, &fb_damage_clips);
 	}
 
+	int in_fence_fd = -1;
+	if (state->base->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+		in_fence_fd = wlr_render_timeline_export_sync_file(state->base->wait_timeline,
+			state->base->wait_point);
+		if (in_fence_fd < 0) {
+			return false;
+		}
+	}
+
 	bool prev_vrr_enabled =
 		output->adaptive_sync_status == WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED;
 	bool vrr_enabled = prev_vrr_enabled;
@@ -285,6 +296,7 @@ bool drm_atomic_connector_prepare(struct wlr_drm_connector_state *state, bool mo
 	state->mode_id = mode_id;
 	state->gamma_lut = gamma_lut;
 	state->fb_damage_clips = fb_damage_clips;
+	state->primary_in_fence_fd = in_fence_fd;
 	state->vrr_enabled = vrr_enabled;
 	return true;
 }
@@ -305,6 +317,15 @@ void drm_atomic_connector_apply_commit(struct wlr_drm_connector_state *state) {
 		WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED : WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED;
 
 	destroy_blob(drm, state->fb_damage_clips);
+	if (state->primary_in_fence_fd >= 0) {
+		close(state->primary_in_fence_fd);
+	}
+	if (state->out_fence_fd >= 0) {
+		// TODO: error handling
+		wlr_render_timeline_import_sync_file(state->base->signal_timeline,
+			state->base->signal_point, state->out_fence_fd);
+		close(state->out_fence_fd);
+	}
 }
 
 void drm_atomic_connector_rollback_commit(struct wlr_drm_connector_state *state) {
@@ -316,6 +337,12 @@ void drm_atomic_connector_rollback_commit(struct wlr_drm_connector_state *state)
 	rollback_blob(drm, &crtc->gamma_lut, state->gamma_lut);
 
 	destroy_blob(drm, state->fb_damage_clips);
+	if (state->primary_in_fence_fd >= 0) {
+		close(state->primary_in_fence_fd);
+	}
+	if (state->out_fence_fd >= 0) {
+		close(state->out_fence_fd);
+	}
 }
 
 static void plane_disable(struct atomic *atom, struct wlr_drm_plane *plane) {
@@ -353,12 +380,37 @@ static void set_plane_props(struct atomic *atom, struct wlr_drm_backend *drm,
 	atomic_add(atom, id, props->crtc_y, (uint64_t)y);
 }
 
-static bool supports_cursor_hotspots(const struct wlr_drm_plane* plane) {
+static bool supports_cursor_hotspots(const struct wlr_drm_plane *plane) {
 	return plane->props.hotspot_x && plane->props.hotspot_y;
 }
 
+static void set_plane_in_fence_fd(struct atomic *atom,
+		struct wlr_drm_plane *plane, int sync_file_fd) {
+	if (!plane->props.in_fence_fd) {
+		wlr_log(WLR_ERROR, "Plane %"PRIu32 " is missing the IN_FENCE_FD property",
+			plane->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, plane->id, plane->props.in_fence_fd, sync_file_fd);
+}
+
+static void set_crtc_out_fence_ptr(struct atomic *atom, struct wlr_drm_crtc *crtc,
+		int *fd_ptr) {
+	if (!crtc->props.out_fence_ptr) {
+		wlr_log(WLR_ERROR,
+			"CRTC %"PRIu32" is missing the OUT_FENCE_PTR property",
+			crtc->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, crtc->id, crtc->props.out_fence_ptr, (uintptr_t)fd_ptr);
+}
+
 static void atomic_connector_add(struct atomic *atom,
-		const struct wlr_drm_connector_state *state, bool modeset) {
+		struct wlr_drm_connector_state *state, bool modeset) {
 	struct wlr_drm_connector *conn = state->connector;
 	struct wlr_drm_backend *drm = conn->backend;
 	struct wlr_drm_crtc *crtc = conn->crtc;
@@ -391,6 +443,12 @@ static void atomic_connector_add(struct atomic *atom,
 			atomic_add(atom, crtc->primary->id,
 				crtc->primary->props.fb_damage_clips, state->fb_damage_clips);
 		}
+		if (state->primary_in_fence_fd >= 0) {
+			set_plane_in_fence_fd(atom, crtc->primary, state->primary_in_fence_fd);
+		}
+		if (state->base->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			set_crtc_out_fence_ptr(atom, crtc, &state->out_fence_fd);
+		}
 		if (crtc->cursor) {
 			if (drm_connector_is_cursor_visible(conn)) {
 				set_plane_props(atom, drm, crtc->cursor, state->cursor_fb,
diff --git a/backend/drm/drm.c b/backend/drm/drm.c
index b2e2c3922032e65d0949eacea0de9abae9b65dd3..15f6915d80609822ae9a9bd9c738ece11a87345b 100644
--- a/backend/drm/drm.c
+++ b/backend/drm/drm.c
@@ -42,7 +42,9 @@ static const uint32_t COMMIT_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_ENABLED |
 	WLR_OUTPUT_STATE_GAMMA_LUT |
 	WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED |
-	WLR_OUTPUT_STATE_LAYERS;
+	WLR_OUTPUT_STATE_LAYERS |
+	WLR_OUTPUT_STATE_WAIT_TIMELINE |
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
 
 static const uint32_t SUPPORTED_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_BACKEND_OPTIONAL | COMMIT_OUTPUT_STATE;
@@ -579,6 +581,8 @@ static void drm_connector_state_init(struct wlr_drm_connector_state *state,
 		.connector = conn,
 		.base = base,
 		.active = output_pending_enabled(&conn->output, base),
+		.primary_in_fence_fd = -1,
+		.out_fence_fd = -1,
 	};
 
 	struct wlr_output_mode *mode = conn->output.current_mode;
@@ -1578,6 +1582,10 @@ static bool connect_drm_connector(struct wlr_drm_connector *wlr_conn,
 		output->non_desktop = non_desktop;
 	}
 
+	// TODO: support sync timelines in multi-GPU mode
+	// TODO: support sync timelines with libliftoff
+	output->timeline = drm->parent == NULL && drm->iface == &atomic_iface;
+
 	memset(wlr_conn->max_bpc_bounds, 0, sizeof(wlr_conn->max_bpc_bounds));
 	if (wlr_conn->props.max_bpc != 0) {
 		if (!introspect_drm_prop_range(drm->fd, wlr_conn->props.max_bpc,
diff --git a/backend/drm/properties.c b/backend/drm/properties.c
index 2058e37cc535a165e1b315cb28fe7cd58838b30d..4a1e0b09fb52841438103051faa04d663c31046d 100644
--- a/backend/drm/properties.c
+++ b/backend/drm/properties.c
@@ -40,6 +40,7 @@ static const struct prop_info crtc_info[] = {
 	{ "GAMMA_LUT", INDEX(gamma_lut) },
 	{ "GAMMA_LUT_SIZE", INDEX(gamma_lut_size) },
 	{ "MODE_ID", INDEX(mode_id) },
+	{ "OUT_FENCE_PTR", INDEX(out_fence_ptr) },
 	{ "VRR_ENABLED", INDEX(vrr_enabled) },
 #undef INDEX
 };
@@ -55,6 +56,7 @@ static const struct prop_info plane_info[] = {
 	{ "FB_ID", INDEX(fb_id) },
 	{ "HOTSPOT_X", INDEX(hotspot_x) },
 	{ "HOTSPOT_Y", INDEX(hotspot_y) },
+	{ "IN_FENCE_FD", INDEX(in_fence_fd) },
 	{ "IN_FORMATS", INDEX(in_formats) },
 	{ "SRC_H", INDEX(src_h) },
 	{ "SRC_W", INDEX(src_w) },
diff --git a/examples/explicit-sync.c b/examples/explicit-sync.c
new file mode 100644
index 0000000000000000000000000000000000000000..860f7bbe9febea937bdaef59f41c94bb725811c3
--- /dev/null
+++ b/examples/explicit-sync.c
@@ -0,0 +1,298 @@
+#include <assert.h>
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <wayland-server-core.h>
+#include <wlr/backend.h>
+#include <wlr/render/allocator.h>
+#include <wlr/render/swapchain.h>
+#include <wlr/render/timeline.h>
+#include <wlr/render/wlr_renderer.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
+#include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_xdg_shell.h>
+#include <wlr/util/log.h>
+
+/* Simple compositor with explicit synchronization support. Input is
+ * unimplemented.
+ *
+ * New surfaces are stacked on top of the existing ones as they appear. */
+
+struct server {
+	struct wl_display *display;
+	struct wlr_backend *backend;
+	struct wlr_allocator *allocator;
+	struct wlr_renderer *renderer;
+	struct wlr_linux_drm_syncobj_manager_v1 *drm_syncobj_manager_v1;
+
+	struct wl_list outputs;
+	struct wl_list surfaces;
+
+	struct wl_listener new_output;
+	struct wl_listener new_surface;
+};
+
+struct surface {
+	struct wlr_surface *wlr;
+	struct wl_list link;
+
+	struct wl_listener commit;
+	struct wl_listener destroy;
+
+	struct output *last_output;
+	uint64_t last_output_point;
+};
+
+struct output {
+	struct wl_list link;
+	struct wlr_output *wlr;
+
+	struct wlr_render_timeline *in_timeline, *out_timeline;
+
+	struct wl_listener frame;
+};
+
+static struct server server = {0};
+
+static void output_handle_frame(struct wl_listener *listener, void *data) {
+	struct output *output = wl_container_of(listener, output, frame);
+	struct wlr_renderer *renderer = server.renderer;
+
+	wlr_output_configure_primary_swapchain(output->wlr, NULL, &output->wlr->swapchain);
+
+	uint64_t output_point = output->wlr->commit_seq;
+	struct wlr_buffer *buffer = wlr_swapchain_acquire(output->wlr->swapchain, NULL);
+	struct wlr_render_pass *pass = wlr_renderer_begin_buffer_pass(renderer, buffer, &(struct wlr_buffer_pass_options){
+		.signal_timeline = output->in_timeline,
+		.signal_point = output_point,
+	});
+
+	wlr_render_pass_add_rect(pass, &(struct wlr_render_rect_options){
+		.box = { .width = output->wlr->width, .height = output->wlr->height },
+		.color = { 0.25, 0.25, 0.25, 1 },
+	});
+
+	struct timespec now;
+	clock_gettime(CLOCK_MONOTONIC, &now);
+
+	int pos = 0;
+	struct surface *surface;
+	wl_list_for_each(surface, &server.surfaces, link) {
+		pos += 50;
+
+		struct wlr_texture *texture = wlr_surface_get_texture(surface->wlr);
+		if (texture == NULL) {
+			continue;
+		}
+
+		struct wlr_render_timeline *wait_timeline = NULL;
+		uint64_t wait_point = 0;
+		struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(surface->wlr);
+		if (sync_v2_state != NULL) {
+			wait_timeline = sync_v2_state->acquire_timeline;
+			wait_point = sync_v2_state->acquire_point;
+		} else {
+			wlr_log(WLR_ERROR, "Client doesn't support linux-drm-syncobj-v1");
+			continue;
+		}
+
+		wlr_render_pass_add_texture(pass, &(struct wlr_render_texture_options){
+			.texture = texture,
+			.dst_box = { .x = pos, .y = pos },
+			.wait_timeline = wait_timeline,
+			.wait_point = wait_point,
+		});
+
+		wlr_surface_send_frame_done(surface->wlr, &now);
+
+		surface->last_output = output;
+		surface->last_output_point = output_point;
+	}
+
+	wlr_render_pass_submit(pass);
+
+	struct wlr_output_state state;
+	wlr_output_state_init(&state);
+	wlr_output_state_set_buffer(&state, buffer);
+	wlr_buffer_unlock(buffer);
+	wlr_output_state_set_wait_timeline(&state, output->in_timeline, output_point);
+	wlr_output_state_set_signal_timeline(&state, output->out_timeline, output_point);
+	wlr_output_commit_state(output->wlr, &state);
+	wlr_output_state_finish(&state);
+
+	wl_list_for_each(surface, &server.surfaces, link) {
+		struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(surface->wlr);
+		if (sync_v2_state != NULL) {
+			if (!wlr_render_timeline_transfer(sync_v2_state->release_timeline,
+					sync_v2_state->release_point, output->out_timeline,
+					output_point)) {
+				wlr_log(WLR_ERROR, "Failed to transfer surface release timeline");
+			}
+		}
+	}
+}
+
+static void server_handle_new_output(struct wl_listener *listener, void *data) {
+	struct wlr_output *wlr_output = data;
+
+	if (!wlr_output->timeline) {
+		wlr_log(WLR_ERROR, "Output doesn't support timelines");
+		return;
+	}
+
+	wlr_output_init_render(wlr_output, server.allocator, server.renderer);
+
+	int drm_fd = wlr_renderer_get_drm_fd(server.renderer);
+	struct wlr_render_timeline *in_timeline = wlr_render_timeline_create(drm_fd);
+	struct wlr_render_timeline *out_timeline = wlr_render_timeline_create(drm_fd);
+	if (in_timeline == NULL || out_timeline == NULL) {
+		return;
+	}
+
+	struct output *output = calloc(1, sizeof(*output));
+	output->wlr = wlr_output;
+	output->in_timeline = in_timeline;
+	output->out_timeline = out_timeline;
+	output->frame.notify = output_handle_frame;
+	wl_signal_add(&wlr_output->events.frame, &output->frame);
+	wl_list_insert(&server.outputs, &output->link);
+
+	struct wlr_output_state state;
+	wlr_output_state_init(&state);
+	wlr_output_state_set_enabled(&state, true);
+	struct wlr_output_mode *mode = wlr_output_preferred_mode(wlr_output);
+	if (mode != NULL) {
+		wlr_output_state_set_mode(&state, mode);
+	}
+	wlr_output_commit_state(wlr_output, &state);
+	wlr_output_state_finish(&state);
+
+	wlr_output_create_global(wlr_output, server.display);
+}
+
+static void surface_handle_commit(struct wl_listener *listener, void *data) {
+	struct surface *surface = wl_container_of(listener, surface, commit);
+	if (!(surface->wlr->current.committed & WLR_SURFACE_STATE_BUFFER)) {
+		return;
+	}
+	struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+		wlr_linux_drm_syncobj_v1_get_surface_state(surface->wlr);
+	if (sync_v2_state == NULL) {
+		return;
+	}
+	// TODO: support multiple outputs
+	struct output *output = surface->last_output;
+	uint64_t output_point = surface->last_output_point;
+	if (output == NULL) {
+		return; // TODO: signal immediately
+	}
+	if (!wlr_render_timeline_transfer(sync_v2_state->release_timeline,
+			sync_v2_state->release_point, output->out_timeline,
+			output_point)) {
+		wlr_log(WLR_ERROR, "Failed to transfer surface release timeline");
+	}
+}
+
+static void surface_handle_destroy(struct wl_listener *listener, void *data) {
+	struct surface *surface = wl_container_of(listener, surface, destroy);
+	wl_list_remove(&surface->destroy.link);
+	wl_list_remove(&surface->commit.link);
+	wl_list_remove(&surface->link);
+	free(surface);
+}
+
+static void server_handle_new_surface(struct wl_listener *listener,
+		void *data) {
+	struct wlr_surface *wlr_surface = data;
+
+	struct surface *surface = calloc(1, sizeof(*surface));
+	surface->wlr = wlr_surface;
+	surface->commit.notify = surface_handle_commit;
+	wl_signal_add(&wlr_surface->events.commit, &surface->commit);
+	surface->destroy.notify = surface_handle_destroy;
+	wl_signal_add(&wlr_surface->events.destroy, &surface->destroy);
+
+	wl_list_insert(&server.surfaces, &surface->link);
+}
+
+int main(int argc, char *argv[]) {
+	wlr_log_init(WLR_DEBUG, NULL);
+
+	const char *startup_cmd = NULL;
+	int c;
+	while ((c = getopt(argc, argv, "s:")) != -1) {
+		switch (c) {
+		case 's':
+			startup_cmd = optarg;
+			break;
+		default:
+			printf("usage: %s [-s startup-command]\n", argv[0]);
+			return EXIT_FAILURE;
+		}
+	}
+	if (optind < argc) {
+		printf("usage: %s [-s startup-command]\n", argv[0]);
+		return EXIT_FAILURE;
+	}
+
+	server.display = wl_display_create();
+	struct wl_event_loop *loop = wl_display_get_event_loop(server.display);
+	server.backend = wlr_backend_autocreate(loop, NULL);
+	server.renderer = wlr_renderer_autocreate(server.backend);
+	server.allocator = wlr_allocator_autocreate(server.backend, server.renderer);
+	wlr_renderer_init_wl_display(server.renderer, server.display);
+
+	if (!server.renderer->features.timeline) {
+		wlr_log(WLR_ERROR, "Renderer doesn't support timelines");
+		return EXIT_FAILURE;
+	}
+
+	struct wlr_compositor *compositor = wlr_compositor_create(server.display, 5, server.renderer);
+
+	wlr_xdg_shell_create(server.display, 2);
+
+	int drm_fd = wlr_renderer_get_drm_fd(server.renderer);
+	server.drm_syncobj_manager_v1 =
+		wlr_linux_drm_syncobj_manager_v1_create(server.display, 1, drm_fd);
+
+	wl_list_init(&server.outputs);
+	wl_list_init(&server.surfaces);
+
+	server.new_output.notify = server_handle_new_output;
+	wl_signal_add(&server.backend->events.new_output, &server.new_output);
+
+	server.new_surface.notify = server_handle_new_surface;
+	wl_signal_add(&compositor->events.new_surface, &server.new_surface);
+
+	const char *socket = wl_display_add_socket_auto(server.display);
+	if (!socket) {
+		wl_display_destroy(server.display);
+		return EXIT_FAILURE;
+	}
+
+	if (!wlr_backend_start(server.backend)) {
+		wl_display_destroy(server.display);
+		return EXIT_FAILURE;
+	}
+
+	setenv("WAYLAND_DISPLAY", socket, true);
+	if (startup_cmd != NULL) {
+		if (fork() == 0) {
+			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, (void *)NULL);
+		}
+	}
+
+	wlr_log(WLR_INFO, "Running Wayland compositor on WAYLAND_DISPLAY=%s",
+		socket);
+	wl_display_run(server.display);
+
+	wl_display_destroy_clients(server.display);
+	wl_display_destroy(server.display);
+	return EXIT_SUCCESS;
+}
diff --git a/examples/meson.build b/examples/meson.build
index 3fe07df8e9bad495ad07069be93eb511d50c0076..a30a63da888d6f87ddf798861be506136797cb4b 100644
--- a/examples/meson.build
+++ b/examples/meson.build
@@ -51,6 +51,10 @@ compositors = {
 		],
 		'dep': [wayland_client, wayland_egl, egl, glesv2],
 	},
+	'explicit-sync': {
+		'src': 'explicit-sync.c',
+		'proto': ['xdg-shell'],
+	},
 }
 
 foreach name, info : compositors
diff --git a/include/backend/drm/drm.h b/include/backend/drm/drm.h
index 8a56a5fc0cbc938f3c506488e257e026a3c3e0eb..e90831842a09ce4d5d647267e16ba617f1f23d48 100644
--- a/include/backend/drm/drm.h
+++ b/include/backend/drm/drm.h
@@ -142,6 +142,7 @@ struct wlr_drm_connector_state {
 	uint32_t mode_id;
 	uint32_t gamma_lut;
 	uint32_t fb_damage_clips;
+	int primary_in_fence_fd, out_fence_fd;
 	bool vrr_enabled;
 };
 
diff --git a/include/backend/drm/properties.h b/include/backend/drm/properties.h
index c924c29b505ace8ff2904054bf3c39ea05d75921..11a01323ed11e346efb7b63ea3af47234c9b1df4 100644
--- a/include/backend/drm/properties.h
+++ b/include/backend/drm/properties.h
@@ -42,6 +42,7 @@ union wlr_drm_crtc_props {
 
 		uint32_t active;
 		uint32_t mode_id;
+		uint32_t out_fence_ptr;
 	};
 	uint32_t props[6];
 };
@@ -67,6 +68,7 @@ union wlr_drm_plane_props {
 		uint32_t fb_damage_clips;
 		uint32_t hotspot_x;
 		uint32_t hotspot_y;
+		uint32_t in_fence_fd;
 	};
 	uint32_t props[16];
 };
diff --git a/include/render/egl.h b/include/render/egl.h
index 0765cce749081f9724e7f383b461214e878502b9..103ab57df73e2e939a90968f91a61e7c67ad5da7 100644
--- a/include/render/egl.h
+++ b/include/render/egl.h
@@ -38,6 +38,10 @@ struct wlr_egl {
 		PFNEGLQUERYDISPLAYATTRIBEXTPROC eglQueryDisplayAttribEXT;
 		PFNEGLQUERYDEVICESTRINGEXTPROC eglQueryDeviceStringEXT;
 		PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT;
+		PFNEGLCREATESYNCKHRPROC eglCreateSyncKHR;
+		PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR;
+		PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
+		PFNEGLWAITSYNCKHRPROC eglWaitSyncKHR;
 	} procs;
 
 	bool has_modifiers;
@@ -105,4 +109,12 @@ bool wlr_egl_make_current(struct wlr_egl *egl, struct wlr_egl_context *save_cont
 
 bool wlr_egl_unset_current(struct wlr_egl *egl);
 
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd);
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync);
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
 #endif
diff --git a/include/render/gles2.h b/include/render/gles2.h
index a472ee9c60928029d35b095763ef62671a73b383..1b7fca961fc23ad7f30bbc0f09a9ef88efeb1a58 100644
--- a/include/render/gles2.h
+++ b/include/render/gles2.h
@@ -138,6 +138,8 @@ struct wlr_gles2_render_pass {
 	float projection_matrix[9];
 	struct wlr_egl_context prev_ctx;
 	struct wlr_gles2_render_timer *timer;
+	struct wlr_render_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 bool is_gles2_pixel_format_supported(const struct wlr_gles2_renderer *renderer,
@@ -169,6 +171,7 @@ void push_gles2_debug_(struct wlr_gles2_renderer *renderer,
 void pop_gles2_debug(struct wlr_gles2_renderer *renderer);
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer);
+	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+	struct wlr_render_timeline *signal_timeline, uint64_t signal_point);
 
 #endif
diff --git a/include/wlr/render/pass.h b/include/wlr/render/pass.h
index 66480f7f7d05e859118fd2f7219a6d7de808b2ec..c00e9e865898c4a6995a9b548ece89645061c98e 100644
--- a/include/wlr/render/pass.h
+++ b/include/wlr/render/pass.h
@@ -33,6 +33,18 @@ struct wlr_buffer_pass_options {
 	/* Color transform to apply to the output of the render pass,
 	 * leave NULL to indicate sRGB/no custom transform */
 	struct wlr_color_transform *color_transform;
+
+	/* Signal a timeline synchronization point when the render pass completes.
+	 *
+	 * When a compositor provides a signal timeline, the renderer may skip
+	 * implicit signal synchronization. Compositors are not allowed to mix
+	 * implicit and explicit signal synchronization usage.
+	 *
+	 * Support for this feature is advertised by features.timeline in
+	 * struct wlr_renderer.
+	 */
+	struct wlr_render_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 /**
@@ -88,6 +100,18 @@ struct wlr_render_texture_options {
 	enum wlr_scale_filter_mode filter_mode;
 	/* Blend mode */
 	enum wlr_render_blend_mode blend_mode;
+
+	/* Wait for a timeline synchronization point before texturing.
+	 *
+	 * When a compositor provides a wait timeline, the renderer may skip
+	 * implicit wait synchronization. Compositors are not allowed to mix
+	 * implicit and explicit wait synchronization usage.
+	 *
+	 * Support for this feature is advertised by features.timeline in
+	 * struct wlr_renderer.
+	 */
+	struct wlr_render_timeline *wait_timeline;
+	uint64_t wait_point;
 };
 
 /**
diff --git a/include/wlr/render/timeline.h b/include/wlr/render/timeline.h
new file mode 100644
index 0000000000000000000000000000000000000000..bfbf7c8667f7efec270c7d228c169c67c7e29bfd
--- /dev/null
+++ b/include/wlr/render/timeline.h
@@ -0,0 +1,99 @@
+#ifndef WLR_RENDER_TIMELINE_H
+#define WLR_RENDER_TIMELINE_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+struct wl_event_loop;
+
+/**
+ * A synchronization timeline.
+ *
+ * Timelines are used to synchronize accesses to buffers. Given a producer
+ * (writing contents to a buffer) and a consumer (reading from the buffer), the
+ * compositor needs to synchronize back-and-forth between these two users. The
+ * consumer needs to wait for the producer to signal that they're done with the
+ * writes, and the producer needs to wait for the consumer to signal that
+ * they're done with the reads.
+ *
+ * Timelines provide synchronization points in the form of monotonically
+ * increasing 64-bit integer values.
+ *
+ * wlroots timelines are designed after Vulkan timeline semaphores. For more
+ * information on the Vulkan APIs, see:
+ * https://www.khronos.org/blog/vulkan-timeline-semaphores
+ *
+ * wlroots timelines are powered by DRM synchronization objects (drm_syncobj):
+ * https://dri.freedesktop.org/docs/drm/gpu/drm-mm.html#drm-sync-objects
+ */
+struct wlr_render_timeline {
+	int drm_fd;
+	uint32_t handle;
+
+	// private state
+
+	size_t n_refs;
+};
+
+typedef void (*wlr_render_timeline_wait_func_t)(void *data);
+
+/**
+ * Create a new synchronization timeline.
+ */
+struct wlr_render_timeline *wlr_render_timeline_create(int drm_fd);
+/**
+ * Import a timeline from a drm_syncobj FD.
+ */
+struct wlr_render_timeline *wlr_render_timeline_import(int drm_fd,
+	int drm_syncobj_fd);
+/**
+ * Reference a synchronization timeline.
+ */
+struct wlr_render_timeline *wlr_render_timeline_ref(struct wlr_render_timeline *timeline);
+/**
+ * Unreference a synchronization timeline.
+ */
+void wlr_render_timeline_unref(struct wlr_render_timeline *timeline);
+/**
+ * Export a drm_syncobj FD from a timeline.
+ */
+int wlr_render_timeline_export(struct wlr_render_timeline *timeline);
+/**
+ * Transfer a point from a timeline to another.
+ *
+ * Both timelines must have been created with the same DRM FD.
+ */
+bool wlr_render_timeline_transfer(struct wlr_render_timeline *dst,
+	uint64_t dst_point, struct wlr_render_timeline *src, uint64_t src_point);
+/**
+ * Asynchronously wait for a timeline point.
+ *
+ * Flags can only be DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE.
+ */
+struct wl_event_source *wlr_render_timeline_wait(struct wlr_render_timeline *timeline,
+	uint64_t point, uint32_t flags, struct wl_event_loop *loop,
+	wlr_render_timeline_wait_func_t func, void *data);
+/**
+ * Export a timeline point as a sync_file FD.
+ *
+ * The returned sync_file will be signalled when the provided point is
+ * signalled on the timeline.
+ *
+ * This allows inter-operation with other APIs which don't support drm_syncobj
+ * yet. The synchronization point needs to have already materialized:
+ * wait-before-signal is not supported.
+ */
+int wlr_render_timeline_export_sync_file(struct wlr_render_timeline *timeline,
+	uint64_t src_point);
+/**
+ * Import a timeline point from a sync_file FD.
+ *
+ * The provided timeline point will be signalled when the provided sync_file is.
+ *
+ * This allows inter-operation with other APIs which don't support drm_syncobj
+ * yet.
+ */
+bool wlr_render_timeline_import_sync_file(struct wlr_render_timeline *timeline,
+	uint64_t dst_point, int sync_file_fd);
+
+#endif
diff --git a/include/wlr/render/wlr_renderer.h b/include/wlr/render/wlr_renderer.h
index bb9a55fcf6d654a31913e913929ab009521fd835..756056a8a88607f536a1e01b4bdc920bb36e3a5f 100644
--- a/include/wlr/render/wlr_renderer.h
+++ b/include/wlr/render/wlr_renderer.h
@@ -45,6 +45,12 @@ struct wlr_renderer {
 		 * Does the renderer support color transforms on its output?
 		 */
 		bool output_color_transform;
+		/**
+		 * Whether wait/signal timelines are supported.
+		 *
+		 * See struct wlr_render_timeline.
+		 */
+		bool timeline;
 	} features;

 	// private state
diff --git a/include/wlr/types/wlr_linux_drm_syncobj_v1.h b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
new file mode 100644
index 0000000000000000000000000000000000000000..b43186fe9800ccd63befce662bff4bac6a3845f8
--- /dev/null
+++ b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
@@ -0,0 +1,46 @@
+/*
+ * This an unstable interface of wlroots. No guarantees are made regarding the
+ * future consistency of this API.
+ */
+#ifndef WLR_USE_UNSTABLE
+#error "Add -DWLR_USE_UNSTABLE to enable unstable wlroots features"
+#endif
+
+#ifndef WLR_TYPES_WLR_LINUX_DRM_SYNCOBJ_V1_H
+#define WLR_TYPES_WLR_LINUX_DRM_SYNCOBJ_V1_H
+
+#include <wayland-server-core.h>
+#include <wlr/util/addon.h>
+
+struct wlr_linux_drm_syncobj_surface_v1_state {
+	struct wlr_render_timeline *acquire_timeline;
+	uint64_t acquire_point;
+
+	struct wlr_render_timeline *release_timeline;
+	uint64_t release_point;
+};
+
+struct wlr_linux_drm_syncobj_manager_v1 {
+	struct wl_global *global;
+
+	// private state
+
+	int drm_fd;
+
+	struct wl_listener display_destroy;
+};
+
+/**
+ * Advertise explicit synchronization support to clients.
+ *
+ * The compositor must be prepared to handle fences coming from clients and to
+ * send release fences correctly. In particular, both the renderer and the
+ * backend need to support explicit synchronization.
+ */
+struct wlr_linux_drm_syncobj_manager_v1 *wlr_linux_drm_syncobj_manager_v1_create(
+	struct wl_display *display, uint32_t version, int drm_fd);
+
+struct wlr_linux_drm_syncobj_surface_v1_state *wlr_linux_drm_syncobj_v1_get_surface_state(
+	struct wlr_surface *surface);
+
+#endif
diff --git a/include/wlr/types/wlr_output.h b/include/wlr/types/wlr_output.h
index d349f8ffa7b7bdb5168d4df3e3b1f4f39a4893c7..5d59ece11e892786adf2a6f7b173fe66a1c0cd29 100644
--- a/include/wlr/types/wlr_output.h
+++ b/include/wlr/types/wlr_output.h
@@ -66,6 +66,8 @@ enum wlr_output_state_field {
 	WLR_OUTPUT_STATE_RENDER_FORMAT = 1 << 8,
 	WLR_OUTPUT_STATE_SUBPIXEL = 1 << 9,
 	WLR_OUTPUT_STATE_LAYERS = 1 << 10,
+	WLR_OUTPUT_STATE_WAIT_TIMELINE = 1 << 11,
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE = 1 << 12,
 };
 
 enum wlr_output_state_mode_type {
@@ -109,6 +111,11 @@ struct wlr_output_state {
 
 	struct wlr_output_layer_state *layers;
 	size_t layers_len;
+
+	struct wlr_render_timeline *wait_timeline;
+	uint64_t wait_point;
+	struct wlr_render_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 struct wlr_output_impl;
@@ -156,6 +163,8 @@ struct wlr_output {
 
 	// true for example with VR headsets
 	bool non_desktop;
+	// Whether wait/signal timelines are supported
+	bool timeline;
 
 	// Commit sequence number. Incremented on each commit, may overflow.
 	uint32_t commit_seq;
@@ -536,6 +545,33 @@ void wlr_output_state_set_damage(struct wlr_output_state *state,
  */
 void wlr_output_state_set_layers(struct wlr_output_state *state,
 	struct wlr_output_layer_state *layers, size_t layers_len);
+/**
+ * Set a timeline point to wait on before displaying the next frame.
+ *
+ * Committing a wait timeline point without a buffer is invalid.
+ *
+ * There is only a single wait timeline point, waiting for multiple timeline
+ * points is unsupported.
+ *
+ * Support for this feature is advertised by the timeline field in
+ * struct wlr_output.
+ */
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+	struct wlr_render_timeline *timeline, uint64_t src_point);
+/**
+ * Set a timeline point to be signalled when the frame is no longer being used
+ * by the backend.
+ *
+ * Committing a signal timeline point without a buffer is invalid.
+ *
+ * There is only a single signal timeline point, signalling multiple timeline
+ * points is unsupported.
+ *
+ * Support for this feature is advertised by the timeline field in
+ * struct wlr_output.
+ */
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+	struct wlr_render_timeline *timeline, uint64_t dst_point);
 
 /**
  * Copies the output state from src to dst. It is safe to then
diff --git a/include/wlr/types/wlr_scene.h b/include/wlr/types/wlr_scene.h
index 2f57ecfc3ef7f43eedffe928e567b4630c54087a..3292e211e18069be6268b4848d3e4cb304a1b449 100644
--- a/include/wlr/types/wlr_scene.h
+++ b/include/wlr/types/wlr_scene.h
@@ -190,6 +190,9 @@ struct wlr_scene_buffer {
 	int buffer_width, buffer_height;
 	bool buffer_is_opaque;
 
+	struct wlr_render_timeline *wait_timeline;
+	uint64_t wait_point;
+
 	struct wl_listener buffer_release;
 	struct wl_listener renderer_destroy;
 };
@@ -223,6 +226,9 @@ struct wlr_scene_output {
 	struct wl_list damage_highlight_regions;
 
 	struct wl_array render_list;
+
+	struct wlr_render_timeline *in_timeline;
+	uint64_t in_point;
 };
 
 struct wlr_scene_timer {
@@ -450,6 +456,9 @@ void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer,
 void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer,
 	struct timespec *now);
 
+void wlr_scene_buffer_set_wait_timeline(struct wlr_scene_buffer *scene_buffer,
+	struct wlr_render_timeline *timeline, uint64_t src_point);
+
 /**
  * Add a viewport for the specified output to the scene-graph.
  *
diff --git a/protocol/meson.build b/protocol/meson.build
index c60f2b9a38bd7e94492d40898960be09e5ca9fe3..a424366d1662493030c7fe95bb614071475d1cef 100644
--- a/protocol/meson.build
+++ b/protocol/meson.build
@@ -27,6 +27,7 @@ protocols = {
 	'ext-idle-notify-v1': wl_protocol_dir / 'staging/ext-idle-notify/ext-idle-notify-v1.xml',
 	'ext-session-lock-v1': wl_protocol_dir / 'staging/ext-session-lock/ext-session-lock-v1.xml',
 	'fractional-scale-v1': wl_protocol_dir / 'staging/fractional-scale/fractional-scale-v1.xml',
+	'linux-drm-syncobj-v1': wl_protocol_dir / 'staging/linux-drm-syncobj/linux-drm-syncobj-v1.xml',
 	'security-context-v1': wl_protocol_dir / 'staging/security-context/security-context-v1.xml',
 	'single-pixel-buffer-v1': wl_protocol_dir / 'staging/single-pixel-buffer/single-pixel-buffer-v1.xml',
 	'xdg-activation-v1': wl_protocol_dir / 'staging/xdg-activation/xdg-activation-v1.xml',
diff --git a/render/egl.c b/render/egl.c
index 19868ca84e95eb1e122f149b3f7fdf1396752da8..ce0c95d914e7f6a115b94680cba554606dc90a45 100644
--- a/render/egl.c
+++ b/render/egl.c
@@ -348,6 +348,18 @@ static bool egl_init_display(struct wlr_egl *egl, EGLDisplay display) {
 		return false;
 	}
 
+	if (check_egl_ext(display_exts_str, "EGL_KHR_fence_sync") &&
+			check_egl_ext(display_exts_str, "EGL_ANDROID_native_fence_sync")) {
+		load_egl_proc(&egl->procs.eglCreateSyncKHR, "eglCreateSyncKHR");
+		load_egl_proc(&egl->procs.eglDestroySyncKHR, "eglDestroySyncKHR");
+		load_egl_proc(&egl->procs.eglDupNativeFenceFDANDROID,
+			"eglDupNativeFenceFDANDROID");
+	}
+
+	if (check_egl_ext(display_exts_str, "EGL_KHR_wait_sync")) {
+		load_egl_proc(&egl->procs.eglWaitSyncKHR, "eglWaitSyncKHR");
+	}
+
 	egl->exts.IMG_context_priority =
 		check_egl_ext(display_exts_str, "EGL_IMG_context_priority");
 
@@ -1014,3 +1026,65 @@ int wlr_egl_dup_drm_fd(struct wlr_egl *egl) {
 	}
 	return fd;
 }
+
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd) {
+	if (!egl->procs.eglCreateSyncKHR) {
+		return EGL_NO_SYNC_KHR;
+	}
+
+	EGLint attribs[3] = { EGL_NONE };
+	int dup_fd = -1;
+	if (fence_fd >= 0) {
+		dup_fd = fcntl(fence_fd, F_DUPFD_CLOEXEC, 0);
+		if (dup_fd < 0) {
+			wlr_log_errno(WLR_ERROR, "dup failed");
+			return EGL_NO_SYNC_KHR;
+		}
+
+		attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+		attribs[1] = dup_fd;
+		attribs[2] = EGL_NONE;
+	}
+
+	EGLSyncKHR sync = egl->procs.eglCreateSyncKHR(egl->display,
+		EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+	if (sync == EGL_NO_SYNC_KHR) {
+		wlr_log(WLR_ERROR, "eglCreateSyncKHR failed");
+		if (dup_fd >= 0) {
+			close(dup_fd);
+		}
+	}
+	return sync;
+}
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (sync == EGL_NO_SYNC_KHR) {
+		return;
+	}
+	assert(egl->procs.eglDestroySyncKHR);
+	if (egl->procs.eglDestroySyncKHR(egl->display, sync) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglDestroySyncKHR failed");
+	}
+}
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (!egl->procs.eglDupNativeFenceFDANDROID) {
+		return -1;
+	}
+
+	int fd = egl->procs.eglDupNativeFenceFDANDROID(egl->display, sync);
+	if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+		wlr_log(WLR_ERROR, "eglDupNativeFenceFDANDROID failed");
+		return -1;
+	}
+
+	return fd;
+}
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (egl->procs.eglWaitSyncKHR(egl->display, sync, 0) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglWaitSyncKHR failed");
+		return false;
+	}
+	return true;
+}
diff --git a/render/gles2/pass.c b/render/gles2/pass.c
index 9177b0a1fafb9269bfaa44caa466e4f6ede57531..6bbaee292383364e106de486e2c292ee7a8dbb04 100644
--- a/render/gles2/pass.c
+++ b/render/gles2/pass.c
@@ -2,8 +2,11 @@
 #include <assert.h>
 #include <pixman.h>
 #include <time.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/util/transform.h>
+#include "render/egl.h"
 #include "render/gles2.h"
 #include "types/wlr_matrix.h"
 
@@ -21,6 +24,7 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 	struct wlr_gles2_render_pass *pass = get_render_pass(wlr_pass);
 	struct wlr_gles2_renderer *renderer = pass->buffer->renderer;
 	struct wlr_gles2_render_timer *timer = pass->timer;
+	bool ok = false;
 
 	push_gles2_debug(renderer);
 
@@ -36,16 +40,40 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 		clock_gettime(CLOCK_MONOTONIC, &timer->cpu_end);
 	}
 
-	glFlush();
+	if (pass->signal_timeline != NULL) {
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, -1);
+		if (sync == EGL_NO_SYNC_KHR) {
+			goto out;
+		}
+
+		int sync_file_fd = wlr_egl_dup_fence_fd(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (sync_file_fd < 0) {
+			goto out;
+		}
+
+		bool ok = wlr_render_timeline_import_sync_file(pass->signal_timeline, pass->signal_point, sync_file_fd);
+		close(sync_file_fd);
+		if (!ok) {
+			goto out;
+		}
+	} else {
+		glFlush();
+	}
+
+	ok = true;
+
+out:
 	glBindFramebuffer(GL_FRAMEBUFFER, 0);
 
 	pop_gles2_debug(renderer);
 	wlr_egl_restore_context(&pass->prev_ctx);
 
+	wlr_render_timeline_unref(pass->signal_timeline);
 	wlr_buffer_unlock(pass->buffer->buffer);
 	free(pass);
 
-	return true;
+	return ok;
 }
 
 static void render(const struct wlr_box *box, const pixman_region32_t *clip, GLint attrib) {
@@ -175,6 +203,27 @@ static void render_pass_add_texture(struct wlr_render_pass *wlr_pass,
 	src_fbox.height /= options->texture->height;
 
 	push_gles2_debug(renderer);
+
+	if (options->wait_timeline != NULL) {
+		int sync_file_fd =
+			wlr_render_timeline_export_sync_file(options->wait_timeline, options->wait_point);
+		if (sync_file_fd < 0) {
+			return;
+		}
+
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, sync_file_fd);
+		close(sync_file_fd);
+		if (sync == EGL_NO_SYNC_KHR) {
+			return;
+		}
+
+		bool ok = wlr_egl_wait_sync(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (!ok) {
+			return;
+		}
+	}
+
 	setup_blending(!texture->has_alpha && alpha == 1.0 ?
 		WLR_RENDER_BLEND_MODE_NONE : options->blend_mode);
 
@@ -247,7 +296,8 @@ static const char *reset_status_str(GLenum status) {
 }
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer) {
+		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+		struct wlr_render_timeline *signal_timeline, uint64_t signal_point) {
 	struct wlr_gles2_renderer *renderer = buffer->renderer;
 	struct wlr_buffer *wlr_buffer = buffer->buffer;
 
@@ -275,6 +325,8 @@ struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *b
 	pass->buffer = buffer;
 	pass->timer = timer;
 	pass->prev_ctx = *prev_ctx;
+	pass->signal_timeline = wlr_render_timeline_ref(signal_timeline);
+	pass->signal_point = signal_point;
 
 	matrix_projection(pass->projection_matrix, wlr_buffer->width, wlr_buffer->height,
 		WL_OUTPUT_TRANSFORM_FLIPPED_180);
diff --git a/render/gles2/renderer.c b/render/gles2/renderer.c
index 4694b2a8f8aa4151c305a976222f10227611b20d..3eeb1ba9c199ddd7a26ead06ba502efb5a0622cd 100644
--- a/render/gles2/renderer.c
+++ b/render/gles2/renderer.c
@@ -259,7 +259,8 @@ static struct wlr_render_pass *gles2_begin_buffer_pass(struct wlr_renderer *wlr_
 		return NULL;
 	}
 
-	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer, &prev_ctx, timer);
+	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer,
+		&prev_ctx, timer, options->signal_timeline, options->signal_point);
 	if (!pass) {
 		return NULL;
 	}
@@ -683,6 +684,9 @@ struct wlr_renderer *wlr_gles2_renderer_create(struct wlr_egl *egl) {
 
 	get_gles2_shm_formats(renderer, &renderer->shm_texture_formats);
 
+	renderer->wlr_renderer.features.timeline =
+		egl->procs.eglDupNativeFenceFDANDROID && egl->procs.eglWaitSyncKHR;
+
 	return &renderer->wlr_renderer;
 
 error:
diff --git a/render/meson.build b/render/meson.build
index e3c5f5350a56ecd7fce6fb8d7c948c167f782efd..22b97e23f3c66dee0fcb6cdc491fe75a87c3182c 100644
--- a/render/meson.build
+++ b/render/meson.build
@@ -12,6 +12,7 @@ wlr_files += files(
 	'pass.c',
 	'pixel_format.c',
 	'swapchain.c',
+	'timeline.c',
 	'wlr_renderer.c',
 	'wlr_texture.c',
 )
@@ -22,6 +23,8 @@ else
 	wlr_files += files('dmabuf_fallback.c')
 endif
 
+internal_config.set10('HAVE_EVENTFD', cc.has_header('sys/eventfd.h'))
+
 if 'gles2' in renderers or 'auto' in renderers
 	egl = dependency('egl', required: 'gles2' in renderers)
 	gbm = dependency('gbm', required: 'gles2' in renderers)
diff --git a/render/timeline.c b/render/timeline.c
new file mode 100644
index 0000000000000000000000000000000000000000..180f3aa6ede201bdb5de4f2a91dfead9cfd8ccdb
--- /dev/null
+++ b/render/timeline.c
@@ -0,0 +1,230 @@
+#include <assert.h>
+#include <xf86drm.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <wayland-server-core.h>
+#include <wlr/render/timeline.h>
+#include <wlr/util/log.h>
+
+#include "config.h"
+
+#if HAVE_EVENTFD
+#include <sys/eventfd.h>
+#endif
+
+struct wlr_render_timeline *wlr_render_timeline_create(int drm_fd) {
+	struct wlr_render_timeline *timeline = calloc(1, sizeof(*timeline));
+	if (timeline == NULL) {
+		return NULL;
+	}
+	timeline->drm_fd = drm_fd;
+	timeline->n_refs = 1;
+
+	if (drmSyncobjCreate(drm_fd, 0, &timeline->handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjCreate failed");
+		free(timeline);
+		return NULL;
+	}
+
+	return timeline;
+}
+
+struct wlr_render_timeline *wlr_render_timeline_import(int drm_fd,
+		int drm_syncobj_fd) {
+	struct wlr_render_timeline *timeline = calloc(1, sizeof(*timeline));
+	if (timeline == NULL) {
+		return NULL;
+	}
+	timeline->drm_fd = drm_fd;
+	timeline->n_refs = 1;
+
+	if (drmSyncobjFDToHandle(drm_fd, drm_syncobj_fd, &timeline->handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjFDToHandle failed");
+		free(timeline);
+		return NULL;
+	}
+
+	return timeline;
+}
+
+struct wlr_render_timeline *wlr_render_timeline_ref(struct wlr_render_timeline *timeline) {
+	timeline->n_refs++;
+	return timeline;
+}
+
+void wlr_render_timeline_unref(struct wlr_render_timeline *timeline) {
+	if (timeline == NULL) {
+		return;
+	}
+
+	assert(timeline->n_refs > 0);
+	timeline->n_refs--;
+	if (timeline->n_refs > 0) {
+		return;
+	}
+
+	drmSyncobjDestroy(timeline->drm_fd, timeline->handle);
+	free(timeline);
+}
+
+int wlr_render_timeline_export(struct wlr_render_timeline *timeline) {
+	int drm_syncobj_fd = -1;
+	if (drmSyncobjHandleToFD(timeline->drm_fd, timeline->handle, &drm_syncobj_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjHandleToFD failed");
+		return -1;
+	}
+	return drm_syncobj_fd;
+}
+
+bool wlr_render_timeline_transfer(struct wlr_render_timeline *dst,
+		uint64_t dst_point, struct wlr_render_timeline *src, uint64_t src_point) {
+	assert(dst->drm_fd == src->drm_fd);
+
+	if (drmSyncobjTransfer(dst->drm_fd, dst->handle, dst_point,
+			src->handle, src_point, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		return false;
+	}
+
+	return true;
+}
+
+int wlr_render_timeline_export_sync_file(struct wlr_render_timeline *timeline,
+		uint64_t src_point) {
+	int sync_file_fd = -1;
+
+	uint32_t syncobj_handle;
+	if (drmSyncobjCreate(timeline->drm_fd, 0, &syncobj_handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjCreate failed");
+		return -1;
+	}
+
+	if (drmSyncobjTransfer(timeline->drm_fd, syncobj_handle, 0,
+			timeline->handle, src_point, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		goto out;
+	}
+
+	if (drmSyncobjExportSyncFile(timeline->drm_fd,
+			syncobj_handle, &sync_file_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjExportSyncFile failed");
+		goto out;
+	}
+
+out:
+	drmSyncobjDestroy(timeline->drm_fd, syncobj_handle);
+	return sync_file_fd;
+}
+
+bool wlr_render_timeline_import_sync_file(struct wlr_render_timeline *timeline,
+		uint64_t dst_point, int sync_file_fd) {
+	bool ok = false;
+
+	uint32_t syncobj_handle;
+	if (drmSyncobjCreate(timeline->drm_fd, 0, &syncobj_handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjCreate failed");
+		return -1;
+	}
+
+	if (drmSyncobjImportSyncFile(timeline->drm_fd, syncobj_handle,
+			sync_file_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjImportSyncFile failed");
+		goto out;
+	}
+
+	if (drmSyncobjTransfer(timeline->drm_fd, timeline->handle, dst_point,
+			syncobj_handle, 0, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		goto out;
+	}
+
+	ok = true;
+
+out:
+	drmSyncobjDestroy(timeline->drm_fd, syncobj_handle);
+	return ok;
+}
+
+struct wlr_render_timeline_waiter {
+	wlr_render_timeline_wait_func_t func;
+	void *data;
+};
+
+static int handle_eventfd_ready(int ev_fd, uint32_t mask, void *data) {
+	struct wlr_render_timeline_waiter *waiter = data;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		wlr_log(WLR_ERROR, "Failed to wait for render timeline: eventfd error");
+	}
+
+	if (mask & WL_EVENT_READABLE) {
+		uint64_t ev_fd_value;
+		if (read(ev_fd, &ev_fd_value, sizeof(ev_fd_value)) <= 0) {
+			wlr_log(WLR_ERROR, "Failed to wait for render timeline: read() failed");
+		}
+	}
+
+	close(ev_fd);
+	waiter->func(waiter->data);
+	free(waiter);
+	return 0;
+}
+
+struct wl_event_source *wlr_render_timeline_wait(struct wlr_render_timeline *timeline,
+		uint64_t point, uint32_t flags, struct wl_event_loop *loop,
+		wlr_render_timeline_wait_func_t func, void *data) {
+	int etime;
+#if defined(__FreeBSD__)
+	etime = ETIMEDOUT;
+#else
+	etime = ETIME;
+#endif
+
+	uint32_t signaled_point;
+	int ret = drmSyncobjTimelineWait(timeline->drm_fd, &timeline->handle, &point, 1, 0, flags, &signaled_point);
+	if (ret == 0) {
+		func(data);
+		return NULL;
+	} else if (ret != -etime) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjWait() failed");
+		return NULL;
+	}
+
+	int ev_fd;
+#if HAVE_EVENTFD
+	ev_fd = eventfd(0, EFD_CLOEXEC);
+	if (ev_fd < 0) {
+		wlr_log_errno(WLR_ERROR, "eventfd() failed");
+	}
+#else
+	ev_fd = -1;
+	wlr_log(WLR_ERROR, "eventfd() is unavailable");
+#endif
+	if (ev_fd < 0) {
+		return NULL;
+	}
+
+	struct drm_syncobj_eventfd syncobj_eventfd = {
+		.handle = timeline->handle,
+		.flags = flags,
+		.point = point,
+		.fd = ev_fd,
+	};
+	if (drmIoctl(timeline->drm_fd, DRM_IOCTL_SYNCOBJ_EVENTFD, &syncobj_eventfd) != 0) {
+		wlr_log_errno(WLR_ERROR, "DRM_IOCTL_SYNCOBJ_EVENTFD failed");
+		close(ev_fd);
+		return NULL;
+	}
+
+	struct wlr_render_timeline_waiter *waiter = calloc(1, sizeof(*waiter));
+	if (waiter == NULL) {
+		wlr_log(WLR_ERROR, "Allocation failed");
+		close(ev_fd);
+		return NULL;
+	}
+
+	waiter->func = func;
+	waiter->data = data;
+
+	return wl_event_loop_add_fd(loop, ev_fd, WL_EVENT_READABLE, handle_eventfd_ready, waiter);
+}
diff --git a/types/meson.build b/types/meson.build
index 9ea0d5402dec1ac1766634c69d368ee05e5caf29..ec70d4b7c26122d7a920decf098320a50550af4c 100644
--- a/types/meson.build
+++ b/types/meson.build
@@ -55,6 +55,7 @@ wlr_files += files(
 	'wlr_keyboard_shortcuts_inhibit_v1.c',
 	'wlr_layer_shell_v1.c',
 	'wlr_linux_dmabuf_v1.c',
+	'wlr_linux_drm_syncobj_v1.c',
 	'wlr_matrix.c',
 	'wlr_output_layer.c',
 	'wlr_output_layout.c',
diff --git a/types/output/output.c b/types/output/output.c
index 818f4549e9245968a4f6093eb3165bee5a493e45..1c9a007796aa4906d2f61c820a4e0ac5453bcf21 100644
--- a/types/output/output.c
+++ b/types/output/output.c
@@ -563,9 +563,19 @@ static bool output_basic_test(struct wlr_output *output,
 			wlr_log(WLR_DEBUG, "Primary buffer size mismatch");
 			return false;
 		}
-	} else if (state->tearing_page_flip) {
-		wlr_log(WLR_ERROR, "Trying to commit a tearing page flip without a buffer?");
-		return false;
+	} else {
+		if (state->tearing_page_flip) {
+			wlr_log(WLR_ERROR, "Tried to commit a tearing page flip without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set wait timeline without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set signal timeline without a buffer");
+			return false;
+		}
 	}
 
 	if (state->committed & WLR_OUTPUT_STATE_RENDER_FORMAT) {
@@ -632,6 +642,12 @@ static bool output_basic_test(struct wlr_output *output,
 		}
 	}
 
+	if ((state->committed & (WLR_OUTPUT_STATE_WAIT_TIMELINE | WLR_OUTPUT_STATE_SIGNAL_TIMELINE)) &&
+			!output->timeline) {
+		wlr_log(WLR_DEBUG, "Wait/signal timelines are not supported for this output");
+		return false;
+	}
+
 	return true;
 }
 
diff --git a/types/output/state.c b/types/output/state.c
index 0909b3e8ac15927c2e94c9c80028dee16fcadaf6..4146fc750b5071517c8d02b34b6d5c12d61b53a5 100644
--- a/types/output/state.c
+++ b/types/output/state.c
@@ -1,5 +1,6 @@
 #include <stdlib.h>
 #include <string.h>
+#include <wlr/render/timeline.h>
 #include <wlr/util/log.h>
 #include "types/wlr_output.h"
 
@@ -16,6 +17,8 @@ void wlr_output_state_finish(struct wlr_output_state *state) {
 	state->buffer = NULL;
 	pixman_region32_fini(&state->damage);
 	free(state->gamma_lut);
+	wlr_render_timeline_unref(state->wait_timeline);
+	wlr_render_timeline_unref(state->signal_timeline);
 }
 
 void wlr_output_state_set_enabled(struct wlr_output_state *state,
@@ -114,6 +117,22 @@ void wlr_output_state_set_layers(struct wlr_output_state *state,
 	state->layers_len = layers_len;
 }
 
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+		struct wlr_render_timeline *timeline, uint64_t src_point) {
+	state->committed |= WLR_OUTPUT_STATE_WAIT_TIMELINE;
+	wlr_render_timeline_unref(state->wait_timeline);
+	state->wait_timeline = wlr_render_timeline_ref(timeline);
+	state->wait_point = src_point;
+}
+
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+		struct wlr_render_timeline *timeline, uint64_t dst_point) {
+	state->committed |= WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
+	wlr_render_timeline_unref(state->signal_timeline);
+	state->signal_timeline = wlr_render_timeline_ref(timeline);
+	state->signal_point = dst_point;
+}
+
 bool wlr_output_state_copy(struct wlr_output_state *dst,
 		const struct wlr_output_state *src) {
 	struct wlr_output_state copy = *src;
@@ -142,6 +161,15 @@ bool wlr_output_state_copy(struct wlr_output_state *dst,
 		}
 	}
 
+	if (src->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+		wlr_output_state_set_wait_timeline(&copy, src->wait_timeline,
+			src->wait_point);
+	}
+	if (src->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+		wlr_output_state_set_signal_timeline(&copy, src->signal_timeline,
+			src->signal_point);
+	}
+
 	wlr_output_state_finish(dst);
 	*dst = copy;
 	return true;
diff --git a/types/scene/surface.c b/types/scene/surface.c
index e0f61f510687f27271bc26942e41c4eb667e737e..f59edfbe6aada2d7ea91f9d0e8fa64f4ad604c42 100644
--- a/types/scene/surface.c
+++ b/types/scene/surface.c
@@ -4,6 +4,7 @@
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/util/transform.h>
 #include "types/wlr_scene.h"
@@ -140,6 +141,7 @@ static void surface_reconfigure(struct wlr_scene_surface *scene_surface) {
 
 	if (width <= 0 || height <= 0) {
 		wlr_scene_buffer_set_buffer(scene_buffer, NULL);
+		wlr_scene_buffer_set_wait_timeline(scene_buffer, NULL, 0);
 		pixman_region32_fini(&opaque);
 		return;
 	}
@@ -169,6 +171,16 @@ static void surface_reconfigure(struct wlr_scene_surface *scene_surface) {
 	}
 
 	pixman_region32_fini(&opaque);
+
+	struct wlr_render_timeline *wait_timeline = NULL;
+	uint64_t wait_point = 0;
+	struct wlr_linux_drm_syncobj_surface_v1_state *syncobj_surface =
+		wlr_linux_drm_syncobj_v1_get_surface_state(surface);
+	if (syncobj_surface != NULL) {
+		wait_timeline = syncobj_surface->acquire_timeline;
+		wait_point = syncobj_surface->acquire_point;
+	}
+	wlr_scene_buffer_set_wait_timeline(scene_buffer, wait_timeline, wait_point);
 }
 
 static void handle_scene_surface_surface_commit(
diff --git a/types/scene/wlr_scene.c b/types/scene/wlr_scene.c
index 78c322d464cf40e62cb3af04c92ac979fa323480..a68204fc90467c990182b71a87280f8b84145fcd 100644
--- a/types/scene/wlr_scene.c
+++ b/types/scene/wlr_scene.c
@@ -3,6 +3,7 @@
 #include <string.h>
 #include <wlr/backend.h>
 #include <wlr/render/swapchain.h>
+#include <wlr/render/timeline.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_damage_ring.h>
@@ -117,6 +118,7 @@ void wlr_scene_node_destroy(struct wlr_scene_node *node) {
 		scene_buffer_set_buffer(scene_buffer, NULL);
 		scene_buffer_set_texture(scene_buffer, NULL);
 		pixman_region32_fini(&scene_buffer->opaque_region);
+		wlr_render_timeline_unref(scene_buffer->wait_timeline);
 	} else if (node->type == WLR_SCENE_NODE_TREE) {
 		struct wlr_scene_tree *scene_tree = wlr_scene_tree_from_node(node);
 
@@ -897,6 +899,13 @@ void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer,
 	scene_node_update(&scene_buffer->node, NULL);
 }
 
+void wlr_scene_buffer_set_wait_timeline(struct wlr_scene_buffer *scene_buffer,
+		struct wlr_render_timeline *timeline, uint64_t src_point) {
+	wlr_render_timeline_unref(scene_buffer->wait_timeline);
+	scene_buffer->wait_timeline = wlr_render_timeline_ref(timeline);
+	scene_buffer->wait_point = src_point;
+}
+
 static struct wlr_texture *scene_buffer_get_texture(
 		struct wlr_scene_buffer *scene_buffer, struct wlr_renderer *renderer) {
 	if (scene_buffer->buffer == NULL || scene_buffer->texture != NULL) {
@@ -1239,6 +1248,8 @@ static void scene_entry_render(struct render_list_entry *entry, const struct ren
 			.filter_mode = scene_buffer->filter_mode,
 			.blend_mode = pixman_region32_not_empty(&opaque) ?
 				WLR_RENDER_BLEND_MODE_PREMULTIPLIED : WLR_RENDER_BLEND_MODE_NONE,
+			.wait_timeline = scene_buffer->wait_timeline,
+			.wait_point = scene_buffer->wait_point,
 		});
 
 		struct wlr_scene_output_sample_event sample_event = {
@@ -1392,6 +1403,14 @@ struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene,
 		prev_output_link = &current_output->link;
 	}
 
+	int drm_fd = wlr_backend_get_drm_fd(output->backend);
+	if (drm_fd >= 0 && output->timeline && output->renderer != NULL && output->renderer->features.timeline) {
+		scene_output->in_timeline = wlr_render_timeline_create(drm_fd);
+		if (scene_output->in_timeline == NULL) {
+			return NULL;
+		}
+	}
+
 	scene_output->index = prev_output_index + 1;
 	assert(scene_output->index < 64);
 	wl_list_insert(prev_output_link, &scene_output->link);
@@ -1440,7 +1459,7 @@ void wlr_scene_output_destroy(struct wlr_scene_output *scene_output) {
 	wl_list_remove(&scene_output->output_commit.link);
 	wl_list_remove(&scene_output->output_damage.link);
 	wl_list_remove(&scene_output->output_needs_frame.link);
-
+	wlr_render_timeline_unref(scene_output->in_timeline);
 	wl_array_release(&scene_output->render_list);
 	free(scene_output);
 }
@@ -1653,6 +1672,9 @@ static bool scene_entry_try_direct_scanout(struct render_list_entry *entry,
 	}
 
 	wlr_output_state_set_buffer(&pending, buffer->buffer);
+	if (buffer->wait_timeline != NULL) {
+		wlr_output_state_set_wait_timeline(&pending, buffer->wait_timeline, buffer->wait_point);
+	}
 
 	if (!wlr_output_test_state(scene_output->output, &pending)) {
 		wlr_output_state_finish(&pending);
@@ -1858,10 +1880,13 @@ bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output,
 		timer->pre_render_duration = timespec_to_nsec(&duration);
 	}
 
+	scene_output->in_point++;
 	struct wlr_render_pass *render_pass = wlr_renderer_begin_buffer_pass(output->renderer, buffer,
 			&(struct wlr_buffer_pass_options){
 		.timer = timer ? timer->render_timer : NULL,
 		.color_transform = options->color_transform,
+		.signal_timeline = scene_output->in_timeline,
+		.signal_point = scene_output->in_point,
 	});
 	if (render_pass == NULL) {
 		wlr_buffer_unlock(buffer);
@@ -1968,6 +1993,11 @@ bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output,
 	wlr_output_state_set_buffer(state, buffer);
 	wlr_buffer_unlock(buffer);
 
+	if (scene_output->in_timeline != NULL) {
+		wlr_output_state_set_wait_timeline(state, scene_output->in_timeline,
+			scene_output->in_point);
+	}
+
 	return true;
 }
 
diff --git a/types/wlr_linux_drm_syncobj_v1.c b/types/wlr_linux_drm_syncobj_v1.c
new file mode 100644
index 0000000000000000000000000000000000000000..b6ba94e3af26f80cdf41d4af40a0fcca8013d1a9
--- /dev/null
+++ b/types/wlr_linux_drm_syncobj_v1.c
@@ -0,0 +1,443 @@
+#include <assert.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
+#include <wlr/util/log.h>
+#include <xf86drm.h>
+#include "config.h"
+#include "linux-drm-syncobj-v1-protocol.h"
+
+#define LINUX_DRM_SYNCOBJ_V1_VERSION 1
+
+struct wlr_linux_drm_syncobj_surface_v1 {
+	struct wl_resource *resource;
+	struct wlr_surface *surface;
+	struct wlr_linux_drm_syncobj_surface_v1_state pending, current;
+
+	struct wlr_addon addon;
+	struct wlr_surface_synced synced;
+
+	struct wl_listener client_commit;
+};
+
+struct wlr_linux_drm_syncobj_surface_v1_commit {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface;
+	uint32_t cached_seq;
+	struct wl_event_source *event_source;
+	struct wl_listener surface_destroy;
+};
+
+static const struct wp_linux_drm_syncobj_manager_v1_interface manager_impl;
+static const struct wp_linux_drm_syncobj_timeline_v1_interface timeline_impl;
+static const struct wp_linux_drm_syncobj_surface_v1_interface surface_impl;
+
+static struct wlr_linux_drm_syncobj_manager_v1 *manager_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&wp_linux_drm_syncobj_manager_v1_interface, &manager_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+static struct wlr_render_timeline *timeline_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&wp_linux_drm_syncobj_timeline_v1_interface, &timeline_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+// Returns NULL if the syncobj surface is inert
+static struct wlr_linux_drm_syncobj_surface_v1 *surface_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&wp_linux_drm_syncobj_surface_v1_interface, &surface_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+static void timeline_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_render_timeline *timeline = timeline_from_resource(resource);
+	wlr_render_timeline_unref(timeline);
+}
+
+static void timeline_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static const struct wp_linux_drm_syncobj_timeline_v1_interface timeline_impl = {
+	.destroy = timeline_handle_destroy,
+};
+
+static void surface_destroy(struct wlr_linux_drm_syncobj_surface_v1 *surface) {
+	if (surface == NULL) {
+		return;
+	}
+	wl_list_remove(&surface->client_commit.link);
+	wlr_addon_finish(&surface->addon);
+	wlr_surface_synced_finish(&surface->synced);
+	wl_resource_set_user_data(surface->resource, NULL);
+	free(surface);
+}
+
+static void surface_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static void surface_handle_set_acquire_point(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *timeline_resource,
+		uint32_t point_hi, uint32_t point_lo) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_resource(resource);
+	if (surface == NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_SURFACE,
+			"The surface has been destroyed");
+		return;
+	}
+
+	struct wlr_render_timeline *timeline =
+		timeline_from_resource(timeline_resource);
+	uint64_t point = (uint64_t)point_hi << 32 | point_lo;
+
+	wlr_render_timeline_unref(surface->pending.acquire_timeline);
+	surface->pending.acquire_timeline = wlr_render_timeline_ref(timeline);
+	surface->pending.acquire_point = point;
+}
+
+static void surface_handle_set_release_point(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *timeline_resource,
+		uint32_t point_hi, uint32_t point_lo) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_resource(resource);
+	if (surface == NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_SURFACE,
+			"The surface has been destroyed");
+		return;
+	}
+
+	struct wlr_render_timeline *timeline =
+		timeline_from_resource(timeline_resource);
+	uint64_t point = (uint64_t)point_hi << 32 | point_lo;
+
+	wlr_render_timeline_unref(surface->pending.release_timeline);
+	surface->pending.release_timeline = wlr_render_timeline_ref(timeline);
+	surface->pending.release_point = point;
+}
+
+static const struct wp_linux_drm_syncobj_surface_v1_interface surface_impl = {
+	.destroy = surface_handle_destroy,
+	.set_acquire_point = surface_handle_set_acquire_point,
+	.set_release_point = surface_handle_set_release_point,
+};
+
+static void surface_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_resource(resource);
+	surface_destroy(surface);
+}
+
+static void surface_addon_handle_surface_destroy(struct wlr_addon *addon) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		wl_container_of(addon, surface, addon);
+	surface_destroy(surface);
+}
+
+static const struct wlr_addon_interface surface_addon_impl = {
+	.name = "wp_linux_drm_syncobj_surface_v1",
+	.destroy = surface_addon_handle_surface_destroy,
+};
+
+static void surface_synced_finish_state(void *_state) {
+	struct wlr_linux_drm_syncobj_surface_v1_state *state = _state;
+	wlr_render_timeline_unref(state->acquire_timeline);
+	wlr_render_timeline_unref(state->release_timeline);
+}
+
+static void surface_synced_move_state(void *_dst, void *_src) {
+	struct wlr_linux_drm_syncobj_surface_v1_state *dst = _dst, *src = _src;
+	// TODO: immediately signal dst.release_timeline if necessary
+	surface_synced_finish_state(dst);
+	*dst = *src;
+	*src = (struct wlr_linux_drm_syncobj_surface_v1_state){0};
+}
+
+static const struct wlr_surface_synced_impl surface_synced_impl = {
+	.state_size = sizeof(struct wlr_linux_drm_syncobj_surface_v1_state),
+	.finish_state = surface_synced_finish_state,
+	.move_state = surface_synced_move_state,
+};
+
+static void manager_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static struct wlr_linux_drm_syncobj_surface_v1 *surface_from_wlr_surface(
+		struct wlr_surface *wlr_surface) {
+	struct wlr_addon *addon =
+		wlr_addon_find(&wlr_surface->addons, NULL, &surface_addon_impl);
+	if (addon == NULL) {
+		return NULL;
+	}
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		wl_container_of(addon, surface, addon);
+	return surface;
+}
+
+static void surface_commit_handle_fence_available(void *data) {
+	struct wlr_linux_drm_syncobj_surface_v1_commit *commit = data;
+	wlr_surface_unlock_cached(commit->surface->surface, commit->cached_seq);
+	wl_event_source_remove(commit->event_source);
+	wl_list_remove(&commit->surface_destroy.link);
+	free(commit);
+}
+
+static void surface_commit_handle_surface_destroy(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_drm_syncobj_surface_v1_commit *commit =
+		wl_container_of(listener, commit, surface_destroy);
+	surface_commit_handle_fence_available(commit);
+}
+
+static void surface_handle_client_commit(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		wl_container_of(listener, surface, client_commit);
+
+	if (surface->pending.acquire_timeline != NULL &&
+			surface->surface->pending.buffer == NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_BUFFER,
+			"Acquire point set but no buffer attached");
+		return;
+	}
+	if (surface->pending.release_timeline != NULL &&
+			surface->surface->pending.buffer == NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_BUFFER,
+			"Release point set but no buffer attached");
+		return;
+	}
+
+	if (surface->pending.acquire_timeline == NULL &&
+			surface->surface->pending.buffer != NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_ACQUIRE_POINT,
+			"Buffer attached but no acquire point set");
+		return;
+	}
+	if (surface->pending.release_timeline == NULL &&
+			surface->surface->pending.buffer != NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_RELEASE_POINT,
+			"Buffer attached but no release point set");
+		return;
+	}
+
+	if (surface->pending.acquire_timeline != NULL &&
+			surface->pending.release_timeline != NULL &&
+			surface->pending.acquire_timeline == surface->pending.release_timeline &&
+			surface->pending.acquire_point >= surface->pending.release_point) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_CONFLICTING_POINTS,
+			"Acquire and release points conflict");
+		return;
+	}
+
+	// Block the surface commit until the fence materializes
+	struct wlr_linux_drm_syncobj_surface_v1_commit *commit = calloc(1, sizeof(*commit));
+	if (commit == NULL) {
+		wl_resource_post_no_memory(surface->resource);
+		return;
+	}
+
+	struct wl_client *client = wl_resource_get_client(surface->resource);
+	struct wl_display *display = wl_client_get_display(client);
+	struct wl_event_loop *loop = wl_display_get_event_loop(display);
+	commit->event_source = wlr_render_timeline_wait(
+		surface->pending.acquire_timeline, surface->pending.acquire_point,
+		DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE, loop,
+		surface_commit_handle_fence_available, commit);
+	if (commit->event_source == NULL) {
+		free(commit);
+		wl_resource_post_no_memory(surface->resource);
+		return;
+	}
+
+	commit->surface = surface;
+	commit->cached_seq = wlr_surface_lock_pending(surface->surface);
+
+	commit->surface_destroy.notify = surface_commit_handle_surface_destroy;
+	wl_signal_add(&surface->surface->events.destroy, &commit->surface_destroy);
+}
+
+static void manager_handle_get_surface(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id,
+		struct wl_resource *surface_resource) {
+	struct wlr_surface *wlr_surface = wlr_surface_from_resource(surface_resource);
+
+	if (surface_from_wlr_surface(wlr_surface) != NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_MANAGER_V1_ERROR_SURFACE_EXISTS,
+			"wp_linux_drm_syncobj_surface_v1 already created for this surface");
+		return;
+	}
+
+	struct wlr_linux_drm_syncobj_surface_v1 *surface = calloc(1, sizeof(*surface));
+	if (surface == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+
+	if (!wlr_surface_synced_init(&surface->synced, wlr_surface,
+			&surface_synced_impl, &surface->pending, &surface->current)) {
+		goto error_surface;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	surface->resource = wl_resource_create(client,
+		&wp_linux_drm_syncobj_surface_v1_interface, version, id);
+	if (surface->resource == NULL) {
+		goto error_surface_synced;
+	}
+	wl_resource_set_implementation(surface->resource,
+		&surface_impl, surface, surface_handle_resource_destroy);
+
+	surface->surface = wlr_surface;
+
+	surface->client_commit.notify = surface_handle_client_commit;
+	wl_signal_add(&wlr_surface->events.client_commit, &surface->client_commit);
+
+	wlr_addon_init(&surface->addon, &wlr_surface->addons, NULL, &surface_addon_impl);
+
+	return;
+
+error_surface_synced:
+	wlr_surface_synced_finish(&surface->synced);
+error_surface:
+	free(surface);
+	wl_resource_post_no_memory(resource);
+}
+
+static void manager_handle_import_timeline(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id, int drm_syncobj_fd) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager =
+		manager_from_resource(resource);
+
+	struct wlr_render_timeline *timeline =
+		wlr_render_timeline_import(manager->drm_fd, drm_syncobj_fd);
+	close(drm_syncobj_fd);
+	if (timeline == NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_MANAGER_V1_ERROR_INVALID_TIMELINE,
+			"Failed to import drm_syncobj timeline");
+		return;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	struct wl_resource *timeline_resource = wl_resource_create(client,
+		&wp_linux_drm_syncobj_timeline_v1_interface, version, id);
+	if (timeline_resource == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+	wl_resource_set_implementation(timeline_resource,
+		&timeline_impl, timeline, timeline_handle_resource_destroy);
+}
+
+static const struct wp_linux_drm_syncobj_manager_v1_interface manager_impl = {
+	.destroy = manager_handle_destroy,
+	.get_surface = manager_handle_get_surface,
+	.import_timeline = manager_handle_import_timeline,
+};
+
+static void manager_bind(struct wl_client *client, void *data,
+		uint32_t version, uint32_t id) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager = data;
+
+	struct wl_resource *resource = wl_resource_create(client,
+		&wp_linux_drm_syncobj_manager_v1_interface, version, id);
+	if (resource == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	wl_resource_set_implementation(resource, &manager_impl, manager, NULL);
+}
+
+static void handle_display_destroy(struct wl_listener *listener, void *data) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager =
+		wl_container_of(listener, manager, display_destroy);
+	wl_list_remove(&manager->display_destroy.link);
+	wl_global_destroy(manager->global);
+	close(manager->drm_fd);
+	free(manager);
+}
+
+static bool check_syncobj_eventfd(int drm_fd) {
+	if (!HAVE_EVENTFD) {
+		return false;
+	}
+
+	uint64_t value = 0;
+	if (drmGetCap(drm_fd, DRM_CAP_SYNCOBJ_TIMELINE, &value) != 0 || value == 0) {
+		return false;
+	}
+
+	// Try waiting with invalid syncobj should fail with ENOENT
+	struct drm_syncobj_eventfd syncobj_eventfd = {
+		.handle = 0,
+		.fd = -1,
+	};
+	return drmIoctl(drm_fd, DRM_IOCTL_SYNCOBJ_EVENTFD, &syncobj_eventfd) != 0 && errno == ENOENT;
+}
+
+struct wlr_linux_drm_syncobj_manager_v1 *wlr_linux_drm_syncobj_manager_v1_create(
+		struct wl_display *display, uint32_t version, int drm_fd) {
+	if (!check_syncobj_eventfd(drm_fd)) {
+		wlr_log(WLR_INFO, "DRM syncobj eventfd unavailable, disabling linux-drm-syncobj-v1");
+		return NULL;
+	}
+
+	struct wlr_linux_drm_syncobj_manager_v1 *manager = calloc(1, sizeof(*manager));
+	if (manager == NULL) {
+		return NULL;
+	}
+
+	manager->drm_fd = fcntl(drm_fd, F_DUPFD_CLOEXEC, 0);
+	if (manager->drm_fd < 0) {
+		goto error_manager;
+	}
+
+	manager->global = wl_global_create(display,
+		&wp_linux_drm_syncobj_manager_v1_interface,
+		LINUX_DRM_SYNCOBJ_V1_VERSION, manager, manager_bind);
+	if (manager->global == NULL) {
+		goto error_drm_fd;
+	}
+
+	manager->display_destroy.notify = handle_display_destroy;
+	wl_display_add_destroy_listener(display, &manager->display_destroy);
+
+	return manager;
+
+error_drm_fd:
+	close(manager->drm_fd);
+error_manager:
+	free(manager);
+	return NULL;
+}
+
+struct wlr_linux_drm_syncobj_surface_v1_state *
+wlr_linux_drm_syncobj_v1_get_surface_state(struct wlr_surface *wlr_surface) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_wlr_surface(wlr_surface);
+	if (surface == NULL) {
+		return NULL;
+	}
+	return &surface->current;
+}
-- 
2.45.0
