explicit-sync-ng branch from emersion (https://gitlab.freedesktop.org/emersion/wlroots/-/tree/explicit-sync-ng?ref_type=heads)

From e0cef4ee296153a2cfc6295ce16eb484955305ad Mon Sep 17 00:00:00 2001
From: Foo Bar <foo@bar.com>
Date: Thu, 13 Jun 2024 11:55:16 -0300
Subject: [PATCH] explicit sync

commit 1f163742f38ddbde5f98903b7278004212a85176
Author: Simon Ser <contact@emersion.fr>
Date:   Fri May 10 18:32:04 2024 +0200

    cursor: add support for linux-drm-syncobj-v1

commit 00f1a63f1761deb69a984c6cc6e04e84c8767ea7
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 15:08:44 2024 +0200

    scene: add explicit synchronization for rendered buffers

commit 30b6bb596c649bae6255625161b2d186c3144050
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 14:37:12 2024 +0200

    scene: add support for linux-drm-syncobj-v1

commit 3a6f13ac7dc33f1c4fd03afdec6ca94784820c6c
Author: Simon Ser <contact@emersion.fr>
Date:   Fri May 10 16:46:15 2024 +0200

    linux-drm-syncobj-v1: add helper to signal on buffer release

commit e18334ca3a570b9ef4623ad002ec07ba3e27db8e
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Apr 3 14:32:30 2024 +0200

    scene: add wlr_scene_buffer_set_wait_timeline()

commit d7fc830602d7d216916f25f590d6bb4a593ac852
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 22:00:39 2021 +0200

    examples/explicit-sync: new example

commit 2886275b541161757cd96f18fe9c4c83c26b18ff
Author: Simon Ser <contact@emersion.fr>
Date:   Tue Feb 27 18:38:12 2024 +0100

    render/drm_syncobj: add wlr_drm_syncobj_timeline_export()

commit 79a9ecf87f8624bda0db7138d8179394a6dea9b3
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Oct 21 15:23:20 2021 +0200

    render/drm_syncobj: add wlr_drm_syncobj_timeline_transfer()

commit e239c03c3f34c1a1525c37884d52d9f8b7113a95
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 20:09:38 2021 +0200

    backend/drm: add support for explicit sync APIs

commit fa514932e713ae2f42f985520b86ca2d2420a4e8
Author: Simon Ser <contact@emersion.fr>
Date:   Wed Oct 20 19:29:00 2021 +0200

    output: add explicit sync API

commit 8f9401e0b98f8c83018dcdedf66c32b03383da5a
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 16:15:59 2023 +0200

    render/gles2: implement explicit sync API

commit 93cc3d80c7730b5cba5e06899208f075a622bfa3
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Mar 16 17:24:25 2020 +0100

    render/egl: add support for explicit sync extensions

commit 5d80393ae3b5f6dcff8bcf7ca35d63e2acc1dce3
Author: Simon Ser <contact@emersion.fr>
Date:   Mon Jul 10 10:53:12 2023 +0200

    render: add explicit sync API
---
 backend/drm/atomic.c                         |  62 +++-
 backend/drm/drm.c                            |  10 +-
 backend/drm/properties.c                     |   2 +
 examples/explicit-sync.c                     | 298 +++++++++++++++++++
 examples/meson.build                         |   4 +
 include/backend/drm/drm.h                    |   1 +
 include/backend/drm/properties.h             |   2 +
 include/render/egl.h                         |  12 +
 include/render/gles2.h                       |   5 +-
 include/types/wlr_output.h                   |   3 +-
 include/wlr/render/drm_syncobj.h             |  11 +
 include/wlr/render/pass.h                    |  24 ++
 include/wlr/render/wlr_renderer.h            |   6 +
 include/wlr/types/wlr_linux_drm_syncobj_v1.h |   9 +
 include/wlr/types/wlr_output.h               |  38 +++
 include/wlr/types/wlr_scene.h                |   9 +
 render/drm_syncobj.c                         |  22 ++
 render/egl.c                                 |  74 +++++
 render/gles2/pass.c                          |  60 +++-
 render/gles2/renderer.c                      |   6 +-
 types/output/cursor.c                        |  21 +-
 types/output/output.c                        |  22 +-
 types/output/state.c                         |  34 ++-
 types/scene/surface.c                        |  18 ++
 types/scene/wlr_scene.c                      |  37 ++-
 types/wlr_cursor.c                           |  20 +-
 types/wlr_linux_drm_syncobj_v1.c             |  37 +++
 27 files changed, 828 insertions(+), 19 deletions(-)
 create mode 100644 examples/explicit-sync.c

diff --git a/backend/drm/atomic.c b/backend/drm/atomic.c
index 9defa7c64c2a62c97565e315c30666d7555425bb..a6880e2191c939f1cc192b7941891b11539f1325 100644
--- a/backend/drm/atomic.c
+++ b/backend/drm/atomic.c
@@ -1,6 +1,8 @@
 #include <drm_fourcc.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/util/log.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
@@ -272,6 +274,15 @@ bool drm_atomic_connector_prepare(struct wlr_drm_connector_state *state, bool mo
 			state->primary_fb->wlr_buf->height, &state->base->damage, &fb_damage_clips);
 	}
 
+	int in_fence_fd = -1;
+	if (state->base->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+		in_fence_fd = wlr_drm_syncobj_timeline_export_sync_file(state->base->wait_timeline,
+			state->base->wait_point);
+		if (in_fence_fd < 0) {
+			return false;
+		}
+	}
+
 	bool prev_vrr_enabled =
 		output->adaptive_sync_status == WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED;
 	bool vrr_enabled = prev_vrr_enabled;
@@ -285,6 +296,7 @@ bool drm_atomic_connector_prepare(struct wlr_drm_connector_state *state, bool mo
 	state->mode_id = mode_id;
 	state->gamma_lut = gamma_lut;
 	state->fb_damage_clips = fb_damage_clips;
+	state->primary_in_fence_fd = in_fence_fd;
 	state->vrr_enabled = vrr_enabled;
 	return true;
 }
@@ -305,6 +317,15 @@ void drm_atomic_connector_apply_commit(struct wlr_drm_connector_state *state) {
 		WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED : WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED;
 
 	destroy_blob(drm, state->fb_damage_clips);
+	if (state->primary_in_fence_fd >= 0) {
+		close(state->primary_in_fence_fd);
+	}
+	if (state->out_fence_fd >= 0) {
+		// TODO: error handling
+		wlr_drm_syncobj_timeline_import_sync_file(state->base->signal_timeline,
+			state->base->signal_point, state->out_fence_fd);
+		close(state->out_fence_fd);
+	}
 }
 
 void drm_atomic_connector_rollback_commit(struct wlr_drm_connector_state *state) {
@@ -316,6 +337,12 @@ void drm_atomic_connector_rollback_commit(struct wlr_drm_connector_state *state)
 	rollback_blob(drm, &crtc->gamma_lut, state->gamma_lut);
 
 	destroy_blob(drm, state->fb_damage_clips);
+	if (state->primary_in_fence_fd >= 0) {
+		close(state->primary_in_fence_fd);
+	}
+	if (state->out_fence_fd >= 0) {
+		close(state->out_fence_fd);
+	}
 }
 
 static void plane_disable(struct atomic *atom, struct wlr_drm_plane *plane) {
@@ -353,12 +380,37 @@ static void set_plane_props(struct atomic *atom, struct wlr_drm_backend *drm,
 	atomic_add(atom, id, props->crtc_y, (uint64_t)y);
 }
 
-static bool supports_cursor_hotspots(const struct wlr_drm_plane* plane) {
+static bool supports_cursor_hotspots(const struct wlr_drm_plane *plane) {
 	return plane->props.hotspot_x && plane->props.hotspot_y;
 }
 
+static void set_plane_in_fence_fd(struct atomic *atom,
+		struct wlr_drm_plane *plane, int sync_file_fd) {
+	if (!plane->props.in_fence_fd) {
+		wlr_log(WLR_ERROR, "Plane %"PRIu32 " is missing the IN_FENCE_FD property",
+			plane->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, plane->id, plane->props.in_fence_fd, sync_file_fd);
+}
+
+static void set_crtc_out_fence_ptr(struct atomic *atom, struct wlr_drm_crtc *crtc,
+		int *fd_ptr) {
+	if (!crtc->props.out_fence_ptr) {
+		wlr_log(WLR_ERROR,
+			"CRTC %"PRIu32" is missing the OUT_FENCE_PTR property",
+			crtc->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, crtc->id, crtc->props.out_fence_ptr, (uintptr_t)fd_ptr);
+}
+
 static void atomic_connector_add(struct atomic *atom,
-		const struct wlr_drm_connector_state *state, bool modeset) {
+		struct wlr_drm_connector_state *state, bool modeset) {
 	struct wlr_drm_connector *conn = state->connector;
 	struct wlr_drm_backend *drm = conn->backend;
 	struct wlr_drm_crtc *crtc = conn->crtc;
@@ -391,6 +443,12 @@ static void atomic_connector_add(struct atomic *atom,
 			atomic_add(atom, crtc->primary->id,
 				crtc->primary->props.fb_damage_clips, state->fb_damage_clips);
 		}
+		if (state->primary_in_fence_fd >= 0) {
+			set_plane_in_fence_fd(atom, crtc->primary, state->primary_in_fence_fd);
+		}
+		if (state->base->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			set_crtc_out_fence_ptr(atom, crtc, &state->out_fence_fd);
+		}
 		if (crtc->cursor) {
 			if (drm_connector_is_cursor_visible(conn)) {
 				set_plane_props(atom, drm, crtc->cursor, state->cursor_fb,
diff --git a/backend/drm/drm.c b/backend/drm/drm.c
index b2e2c3922032e65d0949eacea0de9abae9b65dd3..15f6915d80609822ae9a9bd9c738ece11a87345b 100644
--- a/backend/drm/drm.c
+++ b/backend/drm/drm.c
@@ -42,7 +42,9 @@ static const uint32_t COMMIT_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_ENABLED |
 	WLR_OUTPUT_STATE_GAMMA_LUT |
 	WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED |
-	WLR_OUTPUT_STATE_LAYERS;
+	WLR_OUTPUT_STATE_LAYERS |
+	WLR_OUTPUT_STATE_WAIT_TIMELINE |
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
 
 static const uint32_t SUPPORTED_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_BACKEND_OPTIONAL | COMMIT_OUTPUT_STATE;
@@ -579,6 +581,8 @@ static void drm_connector_state_init(struct wlr_drm_connector_state *state,
 		.connector = conn,
 		.base = base,
 		.active = output_pending_enabled(&conn->output, base),
+		.primary_in_fence_fd = -1,
+		.out_fence_fd = -1,
 	};
 
 	struct wlr_output_mode *mode = conn->output.current_mode;
@@ -1578,6 +1582,10 @@ static bool connect_drm_connector(struct wlr_drm_connector *wlr_conn,
 		output->non_desktop = non_desktop;
 	}
 
+	// TODO: support sync timelines in multi-GPU mode
+	// TODO: support sync timelines with libliftoff
+	output->timeline = drm->parent == NULL && drm->iface == &atomic_iface;
+
 	memset(wlr_conn->max_bpc_bounds, 0, sizeof(wlr_conn->max_bpc_bounds));
 	if (wlr_conn->props.max_bpc != 0) {
 		if (!introspect_drm_prop_range(drm->fd, wlr_conn->props.max_bpc,
diff --git a/backend/drm/properties.c b/backend/drm/properties.c
index 2058e37cc535a165e1b315cb28fe7cd58838b30d..4a1e0b09fb52841438103051faa04d663c31046d 100644
--- a/backend/drm/properties.c
+++ b/backend/drm/properties.c
@@ -40,6 +40,7 @@ static const struct prop_info crtc_info[] = {
 	{ "GAMMA_LUT", INDEX(gamma_lut) },
 	{ "GAMMA_LUT_SIZE", INDEX(gamma_lut_size) },
 	{ "MODE_ID", INDEX(mode_id) },
+	{ "OUT_FENCE_PTR", INDEX(out_fence_ptr) },
 	{ "VRR_ENABLED", INDEX(vrr_enabled) },
 #undef INDEX
 };
@@ -55,6 +56,7 @@ static const struct prop_info plane_info[] = {
 	{ "FB_ID", INDEX(fb_id) },
 	{ "HOTSPOT_X", INDEX(hotspot_x) },
 	{ "HOTSPOT_Y", INDEX(hotspot_y) },
+	{ "IN_FENCE_FD", INDEX(in_fence_fd) },
 	{ "IN_FORMATS", INDEX(in_formats) },
 	{ "SRC_H", INDEX(src_h) },
 	{ "SRC_W", INDEX(src_w) },
diff --git a/examples/explicit-sync.c b/examples/explicit-sync.c
new file mode 100644
index 0000000000000000000000000000000000000000..053f437ecb05d454a271b76be4e4df4754efe591
--- /dev/null
+++ b/examples/explicit-sync.c
@@ -0,0 +1,298 @@
+#include <assert.h>
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <wayland-server-core.h>
+#include <wlr/backend.h>
+#include <wlr/render/allocator.h>
+#include <wlr/render/swapchain.h>
+#include <wlr/render/drm_syncobj.h>
+#include <wlr/render/wlr_renderer.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
+#include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_xdg_shell.h>
+#include <wlr/util/log.h>
+
+/* Simple compositor with explicit synchronization support. Input is
+ * unimplemented.
+ *
+ * New surfaces are stacked on top of the existing ones as they appear. */
+
+struct server {
+	struct wl_display *display;
+	struct wlr_backend *backend;
+	struct wlr_allocator *allocator;
+	struct wlr_renderer *renderer;
+	struct wlr_linux_drm_syncobj_manager_v1 *drm_syncobj_manager_v1;
+
+	struct wl_list outputs;
+	struct wl_list surfaces;
+
+	struct wl_listener new_output;
+	struct wl_listener new_surface;
+};
+
+struct surface {
+	struct wlr_surface *wlr;
+	struct wl_list link;
+
+	struct wl_listener commit;
+	struct wl_listener destroy;
+
+	struct output *last_output;
+	uint64_t last_output_point;
+};
+
+struct output {
+	struct wl_list link;
+	struct wlr_output *wlr;
+
+	struct wlr_drm_syncobj_timeline *in_timeline, *out_timeline;
+
+	struct wl_listener frame;
+};
+
+static struct server server = {0};
+
+static void output_handle_frame(struct wl_listener *listener, void *data) {
+	struct output *output = wl_container_of(listener, output, frame);
+	struct wlr_renderer *renderer = server.renderer;
+
+	wlr_output_configure_primary_swapchain(output->wlr, NULL, &output->wlr->swapchain);
+
+	uint64_t output_point = output->wlr->commit_seq;
+	struct wlr_buffer *buffer = wlr_swapchain_acquire(output->wlr->swapchain, NULL);
+	struct wlr_render_pass *pass = wlr_renderer_begin_buffer_pass(renderer, buffer, &(struct wlr_buffer_pass_options){
+		.signal_timeline = output->in_timeline,
+		.signal_point = output_point,
+	});
+
+	wlr_render_pass_add_rect(pass, &(struct wlr_render_rect_options){
+		.box = { .width = output->wlr->width, .height = output->wlr->height },
+		.color = { 0.25, 0.25, 0.25, 1 },
+	});
+
+	struct timespec now;
+	clock_gettime(CLOCK_MONOTONIC, &now);
+
+	int pos = 0;
+	struct surface *surface;
+	wl_list_for_each(surface, &server.surfaces, link) {
+		pos += 50;
+
+		struct wlr_texture *texture = wlr_surface_get_texture(surface->wlr);
+		if (texture == NULL) {
+			continue;
+		}
+
+		struct wlr_drm_syncobj_timeline *wait_timeline = NULL;
+		uint64_t wait_point = 0;
+		struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(surface->wlr);
+		if (sync_v2_state != NULL) {
+			wait_timeline = sync_v2_state->acquire_timeline;
+			wait_point = sync_v2_state->acquire_point;
+		} else {
+			wlr_log(WLR_ERROR, "Client doesn't support linux-drm-syncobj-v1");
+			continue;
+		}
+
+		wlr_render_pass_add_texture(pass, &(struct wlr_render_texture_options){
+			.texture = texture,
+			.dst_box = { .x = pos, .y = pos },
+			.wait_timeline = wait_timeline,
+			.wait_point = wait_point,
+		});
+
+		wlr_surface_send_frame_done(surface->wlr, &now);
+
+		surface->last_output = output;
+		surface->last_output_point = output_point;
+	}
+
+	wlr_render_pass_submit(pass);
+
+	struct wlr_output_state state;
+	wlr_output_state_init(&state);
+	wlr_output_state_set_buffer(&state, buffer);
+	wlr_buffer_unlock(buffer);
+	wlr_output_state_set_wait_timeline(&state, output->in_timeline, output_point);
+	wlr_output_state_set_signal_timeline(&state, output->out_timeline, output_point);
+	wlr_output_commit_state(output->wlr, &state);
+	wlr_output_state_finish(&state);
+
+	wl_list_for_each(surface, &server.surfaces, link) {
+		struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(surface->wlr);
+		if (sync_v2_state != NULL) {
+			if (!wlr_drm_syncobj_timeline_transfer(sync_v2_state->release_timeline,
+					sync_v2_state->release_point, output->out_timeline,
+					output_point)) {
+				wlr_log(WLR_ERROR, "Failed to transfer surface release timeline");
+			}
+		}
+	}
+}
+
+static void server_handle_new_output(struct wl_listener *listener, void *data) {
+	struct wlr_output *wlr_output = data;
+
+	if (!wlr_output->timeline) {
+		wlr_log(WLR_ERROR, "Output doesn't support timelines");
+		return;
+	}
+
+	wlr_output_init_render(wlr_output, server.allocator, server.renderer);
+
+	int drm_fd = wlr_renderer_get_drm_fd(server.renderer);
+	struct wlr_drm_syncobj_timeline *in_timeline = wlr_drm_syncobj_timeline_create(drm_fd);
+	struct wlr_drm_syncobj_timeline *out_timeline = wlr_drm_syncobj_timeline_create(drm_fd);
+	if (in_timeline == NULL || out_timeline == NULL) {
+		return;
+	}
+
+	struct output *output = calloc(1, sizeof(*output));
+	output->wlr = wlr_output;
+	output->in_timeline = in_timeline;
+	output->out_timeline = out_timeline;
+	output->frame.notify = output_handle_frame;
+	wl_signal_add(&wlr_output->events.frame, &output->frame);
+	wl_list_insert(&server.outputs, &output->link);
+
+	struct wlr_output_state state;
+	wlr_output_state_init(&state);
+	wlr_output_state_set_enabled(&state, true);
+	struct wlr_output_mode *mode = wlr_output_preferred_mode(wlr_output);
+	if (mode != NULL) {
+		wlr_output_state_set_mode(&state, mode);
+	}
+	wlr_output_commit_state(wlr_output, &state);
+	wlr_output_state_finish(&state);
+
+	wlr_output_create_global(wlr_output, server.display);
+}
+
+static void surface_handle_commit(struct wl_listener *listener, void *data) {
+	struct surface *surface = wl_container_of(listener, surface, commit);
+	if (!(surface->wlr->current.committed & WLR_SURFACE_STATE_BUFFER)) {
+		return;
+	}
+	struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+		wlr_linux_drm_syncobj_v1_get_surface_state(surface->wlr);
+	if (sync_v2_state == NULL) {
+		return;
+	}
+	// TODO: support multiple outputs
+	struct output *output = surface->last_output;
+	uint64_t output_point = surface->last_output_point;
+	if (output == NULL) {
+		return; // TODO: signal immediately
+	}
+	if (!wlr_drm_syncobj_timeline_transfer(sync_v2_state->release_timeline,
+			sync_v2_state->release_point, output->out_timeline,
+			output_point)) {
+		wlr_log(WLR_ERROR, "Failed to transfer surface release timeline");
+	}
+}
+
+static void surface_handle_destroy(struct wl_listener *listener, void *data) {
+	struct surface *surface = wl_container_of(listener, surface, destroy);
+	wl_list_remove(&surface->destroy.link);
+	wl_list_remove(&surface->commit.link);
+	wl_list_remove(&surface->link);
+	free(surface);
+}
+
+static void server_handle_new_surface(struct wl_listener *listener,
+		void *data) {
+	struct wlr_surface *wlr_surface = data;
+
+	struct surface *surface = calloc(1, sizeof(*surface));
+	surface->wlr = wlr_surface;
+	surface->commit.notify = surface_handle_commit;
+	wl_signal_add(&wlr_surface->events.commit, &surface->commit);
+	surface->destroy.notify = surface_handle_destroy;
+	wl_signal_add(&wlr_surface->events.destroy, &surface->destroy);
+
+	wl_list_insert(&server.surfaces, &surface->link);
+}
+
+int main(int argc, char *argv[]) {
+	wlr_log_init(WLR_DEBUG, NULL);
+
+	const char *startup_cmd = NULL;
+	int c;
+	while ((c = getopt(argc, argv, "s:")) != -1) {
+		switch (c) {
+		case 's':
+			startup_cmd = optarg;
+			break;
+		default:
+			printf("usage: %s [-s startup-command]\n", argv[0]);
+			return EXIT_FAILURE;
+		}
+	}
+	if (optind < argc) {
+		printf("usage: %s [-s startup-command]\n", argv[0]);
+		return EXIT_FAILURE;
+	}
+
+	server.display = wl_display_create();
+	struct wl_event_loop *loop = wl_display_get_event_loop(server.display);
+	server.backend = wlr_backend_autocreate(loop, NULL);
+	server.renderer = wlr_renderer_autocreate(server.backend);
+	server.allocator = wlr_allocator_autocreate(server.backend, server.renderer);
+	wlr_renderer_init_wl_display(server.renderer, server.display);
+
+	if (!server.renderer->features.timeline) {
+		wlr_log(WLR_ERROR, "Renderer doesn't support timelines");
+		return EXIT_FAILURE;
+	}
+
+	struct wlr_compositor *compositor = wlr_compositor_create(server.display, 5, server.renderer);
+
+	wlr_xdg_shell_create(server.display, 2);
+
+	int drm_fd = wlr_renderer_get_drm_fd(server.renderer);
+	server.drm_syncobj_manager_v1 =
+		wlr_linux_drm_syncobj_manager_v1_create(server.display, 1, drm_fd);
+
+	wl_list_init(&server.outputs);
+	wl_list_init(&server.surfaces);
+
+	server.new_output.notify = server_handle_new_output;
+	wl_signal_add(&server.backend->events.new_output, &server.new_output);
+
+	server.new_surface.notify = server_handle_new_surface;
+	wl_signal_add(&compositor->events.new_surface, &server.new_surface);
+
+	const char *socket = wl_display_add_socket_auto(server.display);
+	if (!socket) {
+		wl_display_destroy(server.display);
+		return EXIT_FAILURE;
+	}
+
+	if (!wlr_backend_start(server.backend)) {
+		wl_display_destroy(server.display);
+		return EXIT_FAILURE;
+	}
+
+	setenv("WAYLAND_DISPLAY", socket, true);
+	if (startup_cmd != NULL) {
+		if (fork() == 0) {
+			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, (void *)NULL);
+		}
+	}
+
+	wlr_log(WLR_INFO, "Running Wayland compositor on WAYLAND_DISPLAY=%s",
+		socket);
+	wl_display_run(server.display);
+
+	wl_display_destroy_clients(server.display);
+	wl_display_destroy(server.display);
+	return EXIT_SUCCESS;
+}
diff --git a/examples/meson.build b/examples/meson.build
index 3fe07df8e9bad495ad07069be93eb511d50c0076..a30a63da888d6f87ddf798861be506136797cb4b 100644
--- a/examples/meson.build
+++ b/examples/meson.build
@@ -51,6 +51,10 @@ compositors = {
 		],
 		'dep': [wayland_client, wayland_egl, egl, glesv2],
 	},
+	'explicit-sync': {
+		'src': 'explicit-sync.c',
+		'proto': ['xdg-shell'],
+	},
 }
 
 foreach name, info : compositors
diff --git a/include/backend/drm/drm.h b/include/backend/drm/drm.h
index 8a56a5fc0cbc938f3c506488e257e026a3c3e0eb..e90831842a09ce4d5d647267e16ba617f1f23d48 100644
--- a/include/backend/drm/drm.h
+++ b/include/backend/drm/drm.h
@@ -142,6 +142,7 @@ struct wlr_drm_connector_state {
 	uint32_t mode_id;
 	uint32_t gamma_lut;
 	uint32_t fb_damage_clips;
+	int primary_in_fence_fd, out_fence_fd;
 	bool vrr_enabled;
 };
 
diff --git a/include/backend/drm/properties.h b/include/backend/drm/properties.h
index c924c29b505ace8ff2904054bf3c39ea05d75921..11a01323ed11e346efb7b63ea3af47234c9b1df4 100644
--- a/include/backend/drm/properties.h
+++ b/include/backend/drm/properties.h
@@ -42,6 +42,7 @@ union wlr_drm_crtc_props {
 
 		uint32_t active;
 		uint32_t mode_id;
+		uint32_t out_fence_ptr;
 	};
 	uint32_t props[6];
 };
@@ -67,6 +68,7 @@ union wlr_drm_plane_props {
 		uint32_t fb_damage_clips;
 		uint32_t hotspot_x;
 		uint32_t hotspot_y;
+		uint32_t in_fence_fd;
 	};
 	uint32_t props[16];
 };
diff --git a/include/render/egl.h b/include/render/egl.h
index 0765cce749081f9724e7f383b461214e878502b9..103ab57df73e2e939a90968f91a61e7c67ad5da7 100644
--- a/include/render/egl.h
+++ b/include/render/egl.h
@@ -38,6 +38,10 @@ struct wlr_egl {
 		PFNEGLQUERYDISPLAYATTRIBEXTPROC eglQueryDisplayAttribEXT;
 		PFNEGLQUERYDEVICESTRINGEXTPROC eglQueryDeviceStringEXT;
 		PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT;
+		PFNEGLCREATESYNCKHRPROC eglCreateSyncKHR;
+		PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR;
+		PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
+		PFNEGLWAITSYNCKHRPROC eglWaitSyncKHR;
 	} procs;
 
 	bool has_modifiers;
@@ -105,4 +109,12 @@ bool wlr_egl_make_current(struct wlr_egl *egl, struct wlr_egl_context *save_cont
 
 bool wlr_egl_unset_current(struct wlr_egl *egl);
 
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd);
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync);
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
 #endif
diff --git a/include/render/gles2.h b/include/render/gles2.h
index a472ee9c60928029d35b095763ef62671a73b383..0f24ae38e56956aa90a6bbfb1dcca2313713d435 100644
--- a/include/render/gles2.h
+++ b/include/render/gles2.h
@@ -138,6 +138,8 @@ struct wlr_gles2_render_pass {
 	float projection_matrix[9];
 	struct wlr_egl_context prev_ctx;
 	struct wlr_gles2_render_timer *timer;
+	struct wlr_drm_syncobj_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 bool is_gles2_pixel_format_supported(const struct wlr_gles2_renderer *renderer,
@@ -169,6 +171,7 @@ void push_gles2_debug_(struct wlr_gles2_renderer *renderer,
 void pop_gles2_debug(struct wlr_gles2_renderer *renderer);
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer);
+	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+	struct wlr_drm_syncobj_timeline *signal_timeline, uint64_t signal_point);
 
 #endif
diff --git a/include/types/wlr_output.h b/include/types/wlr_output.h
index 09be35510818c8ea39137a50f0865530d0b69f02..bd095d8f20251f8b543483f2b7dff5244a52281b 100644
--- a/include/types/wlr_output.h
+++ b/include/types/wlr_output.h
@@ -18,7 +18,8 @@ bool output_ensure_buffer(struct wlr_output *output,
 bool output_cursor_set_texture(struct wlr_output_cursor *cursor,
 	struct wlr_texture *texture, bool own_texture, const struct wlr_fbox *src_box,
 	int dst_width, int dst_height, enum wl_output_transform transform,
-	int32_t hotspot_x, int32_t hotspot_y);
+	int32_t hotspot_x, int32_t hotspot_y, struct wlr_drm_syncobj_timeline *wait_timeline,
+	uint64_t wait_point);
 
 void output_defer_present(struct wlr_output *output, struct wlr_output_event_present event);
 
diff --git a/include/wlr/render/drm_syncobj.h b/include/wlr/render/drm_syncobj.h
index be3dce2d7652c4a2237b084375d9d8ff932312e2..bf406d8716554cc519e7dcc4a5e356c654fe6cc7 100644
--- a/include/wlr/render/drm_syncobj.h
+++ b/include/wlr/render/drm_syncobj.h
@@ -62,6 +62,17 @@ struct wlr_drm_syncobj_timeline *wlr_drm_syncobj_timeline_ref(struct wlr_drm_syn
  * Unreference a synchronization timeline.
  */
 void wlr_drm_syncobj_timeline_unref(struct wlr_drm_syncobj_timeline *timeline);
+/**
+ * Export a drm_syncobj FD from a timeline.
+ */
+int wlr_drm_syncobj_timeline_export(struct wlr_drm_syncobj_timeline *timeline);
+/**
+ * Transfer a point from a timeline to another.
+ *
+ * Both timelines must have been created with the same DRM FD.
+ */
+bool wlr_drm_syncobj_timeline_transfer(struct wlr_drm_syncobj_timeline *dst,
+	uint64_t dst_point, struct wlr_drm_syncobj_timeline *src, uint64_t src_point);
 /**
  * Check if a timeline point has been signalled or has materialized.
  *
diff --git a/include/wlr/render/pass.h b/include/wlr/render/pass.h
index 66480f7f7d05e859118fd2f7219a6d7de808b2ec..aae797dab7c101e66d32aa3e36930e7eab914dc8 100644
--- a/include/wlr/render/pass.h
+++ b/include/wlr/render/pass.h
@@ -33,6 +33,18 @@ struct wlr_buffer_pass_options {
 	/* Color transform to apply to the output of the render pass,
 	 * leave NULL to indicate sRGB/no custom transform */
 	struct wlr_color_transform *color_transform;
+
+	/* Signal a timeline synchronization point when the render pass completes.
+	 *
+	 * When a compositor provides a signal timeline, the renderer may skip
+	 * implicit signal synchronization. Compositors are not allowed to mix
+	 * implicit and explicit signal synchronization usage.
+	 *
+	 * Support for this feature is advertised by features.timeline in
+	 * struct wlr_renderer.
+	 */
+	struct wlr_drm_syncobj_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 /**
@@ -88,6 +100,18 @@ struct wlr_render_texture_options {
 	enum wlr_scale_filter_mode filter_mode;
 	/* Blend mode */
 	enum wlr_render_blend_mode blend_mode;
+
+	/* Wait for a timeline synchronization point before texturing.
+	 *
+	 * When a compositor provides a wait timeline, the renderer may skip
+	 * implicit wait synchronization. Compositors are not allowed to mix
+	 * implicit and explicit wait synchronization usage.
+	 *
+	 * Support for this feature is advertised by features.timeline in
+	 * struct wlr_renderer.
+	 */
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
 };
 
 /**
diff --git a/include/wlr/render/wlr_renderer.h b/include/wlr/render/wlr_renderer.h
index bb9a55fcf6d654a31913e913929ab009521fd835..4a8ccd3981572f075f02a2ef15229b042f75a3a8 100644
--- a/include/wlr/render/wlr_renderer.h
+++ b/include/wlr/render/wlr_renderer.h
@@ -45,6 +45,12 @@ struct wlr_renderer {
 		 * Does the renderer support color transforms on its output?
 		 */
 		bool output_color_transform;
+		/**
+		 * Whether wait/signal timelines are supported.
+		 *
+		 * See struct wlr_drm_syncobj_timeline.
+		 */
+		bool timeline;
 	} features;
 
 	// private state
diff --git a/include/wlr/types/wlr_linux_drm_syncobj_v1.h b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
index c6e0617b1cbec77a93eebf119c4c992a868c1f09..1a29a0d8f1522bd3e74f9f84bf072c5bd1b1fb06 100644
--- a/include/wlr/types/wlr_linux_drm_syncobj_v1.h
+++ b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
@@ -43,4 +43,13 @@ struct wlr_linux_drm_syncobj_manager_v1 *wlr_linux_drm_syncobj_manager_v1_create
 struct wlr_linux_drm_syncobj_surface_v1_state *wlr_linux_drm_syncobj_v1_get_surface_state(
 	struct wlr_surface *surface);
 
+/**
+ * Signal the release point when wlr_buffer.events.release is emitted.
+ *
+ * Compositors unwilling to track fine-grained commit release can call this
+ * helper on surface commit.
+ */
+bool wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(
+	struct wlr_linux_drm_syncobj_surface_v1_state *state, struct wlr_buffer *buffer);
+
 #endif
diff --git a/include/wlr/types/wlr_output.h b/include/wlr/types/wlr_output.h
index d349f8ffa7b7bdb5168d4df3e3b1f4f39a4893c7..aaf4255b67451aaab369f68dfbf84c15afe18611 100644
--- a/include/wlr/types/wlr_output.h
+++ b/include/wlr/types/wlr_output.h
@@ -45,6 +45,8 @@ struct wlr_output_cursor {
 	int32_t hotspot_x, hotspot_y;
 	struct wlr_texture *texture;
 	bool own_texture;
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
 	struct wl_listener renderer_destroy;
 	struct wl_list link;
 };
@@ -66,6 +68,8 @@ enum wlr_output_state_field {
 	WLR_OUTPUT_STATE_RENDER_FORMAT = 1 << 8,
 	WLR_OUTPUT_STATE_SUBPIXEL = 1 << 9,
 	WLR_OUTPUT_STATE_LAYERS = 1 << 10,
+	WLR_OUTPUT_STATE_WAIT_TIMELINE = 1 << 11,
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE = 1 << 12,
 };
 
 enum wlr_output_state_mode_type {
@@ -109,6 +113,11 @@ struct wlr_output_state {
 
 	struct wlr_output_layer_state *layers;
 	size_t layers_len;
+
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
+	struct wlr_drm_syncobj_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 struct wlr_output_impl;
@@ -156,6 +165,8 @@ struct wlr_output {
 
 	// true for example with VR headsets
 	bool non_desktop;
+	// Whether wait/signal timelines are supported
+	bool timeline;
 
 	// Commit sequence number. Incremented on each commit, may overflow.
 	uint32_t commit_seq;
@@ -536,6 +547,33 @@ void wlr_output_state_set_damage(struct wlr_output_state *state,
  */
 void wlr_output_state_set_layers(struct wlr_output_state *state,
 	struct wlr_output_layer_state *layers, size_t layers_len);
+/**
+ * Set a timeline point to wait on before displaying the next frame.
+ *
+ * Committing a wait timeline point without a buffer is invalid.
+ *
+ * There is only a single wait timeline point, waiting for multiple timeline
+ * points is unsupported.
+ *
+ * Support for this feature is advertised by the timeline field in
+ * struct wlr_output.
+ */
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+	struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point);
+/**
+ * Set a timeline point to be signalled when the frame is no longer being used
+ * by the backend.
+ *
+ * Committing a signal timeline point without a buffer is invalid.
+ *
+ * There is only a single signal timeline point, signalling multiple timeline
+ * points is unsupported.
+ *
+ * Support for this feature is advertised by the timeline field in
+ * struct wlr_output.
+ */
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+	struct wlr_drm_syncobj_timeline *timeline, uint64_t dst_point);
 
 /**
  * Copies the output state from src to dst. It is safe to then
diff --git a/include/wlr/types/wlr_scene.h b/include/wlr/types/wlr_scene.h
index a8fc21595ff62372333d7af3f4a442ec11280660..9d6d4ba676ca97bc9155fac7cad06f5b30821684 100644
--- a/include/wlr/types/wlr_scene.h
+++ b/include/wlr/types/wlr_scene.h
@@ -191,6 +191,9 @@ struct wlr_scene_buffer {
 	int buffer_width, buffer_height;
 	bool buffer_is_opaque;
 
+	struct wlr_drm_syncobj_timeline *wait_timeline;
+	uint64_t wait_point;
+
 	struct wl_listener buffer_release;
 	struct wl_listener renderer_destroy;
 };
@@ -224,6 +227,9 @@ struct wlr_scene_output {
 	struct wl_list damage_highlight_regions;
 
 	struct wl_array render_list;
+
+	struct wlr_drm_syncobj_timeline *in_timeline;
+	uint64_t in_point;
 };
 
 struct wlr_scene_timer {
@@ -451,6 +457,9 @@ void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer,
 void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer,
 	struct timespec *now);
 
+void wlr_scene_buffer_set_wait_timeline(struct wlr_scene_buffer *scene_buffer,
+	struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point);
+
 /**
  * Add a viewport for the specified output to the scene-graph.
  *
diff --git a/render/drm_syncobj.c b/render/drm_syncobj.c
index af3e79fcda7b8684663ffb9009f64443509d3fbb..f7120df309eb0c793f86dc498c85af03169fadad 100644
--- a/render/drm_syncobj.c
+++ b/render/drm_syncobj.c
@@ -67,6 +67,28 @@ void wlr_drm_syncobj_timeline_unref(struct wlr_drm_syncobj_timeline *timeline) {
 	free(timeline);
 }
 
+int wlr_drm_syncobj_timeline_export(struct wlr_drm_syncobj_timeline *timeline) {
+	int drm_syncobj_fd = -1;
+	if (drmSyncobjHandleToFD(timeline->drm_fd, timeline->handle, &drm_syncobj_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjHandleToFD failed");
+		return -1;
+	}
+	return drm_syncobj_fd;
+}
+
+bool wlr_drm_syncobj_timeline_transfer(struct wlr_drm_syncobj_timeline *dst,
+		uint64_t dst_point, struct wlr_drm_syncobj_timeline *src, uint64_t src_point) {
+	assert(dst->drm_fd == src->drm_fd);
+
+	if (drmSyncobjTransfer(dst->drm_fd, dst->handle, dst_point,
+			src->handle, src_point, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		return false;
+	}
+
+	return true;
+}
+
 int wlr_drm_syncobj_timeline_export_sync_file(struct wlr_drm_syncobj_timeline *timeline,
 		uint64_t src_point) {
 	int sync_file_fd = -1;
diff --git a/render/egl.c b/render/egl.c
index 19868ca84e95eb1e122f149b3f7fdf1396752da8..ce0c95d914e7f6a115b94680cba554606dc90a45 100644
--- a/render/egl.c
+++ b/render/egl.c
@@ -348,6 +348,18 @@ static bool egl_init_display(struct wlr_egl *egl, EGLDisplay display) {
 		return false;
 	}
 
+	if (check_egl_ext(display_exts_str, "EGL_KHR_fence_sync") &&
+			check_egl_ext(display_exts_str, "EGL_ANDROID_native_fence_sync")) {
+		load_egl_proc(&egl->procs.eglCreateSyncKHR, "eglCreateSyncKHR");
+		load_egl_proc(&egl->procs.eglDestroySyncKHR, "eglDestroySyncKHR");
+		load_egl_proc(&egl->procs.eglDupNativeFenceFDANDROID,
+			"eglDupNativeFenceFDANDROID");
+	}
+
+	if (check_egl_ext(display_exts_str, "EGL_KHR_wait_sync")) {
+		load_egl_proc(&egl->procs.eglWaitSyncKHR, "eglWaitSyncKHR");
+	}
+
 	egl->exts.IMG_context_priority =
 		check_egl_ext(display_exts_str, "EGL_IMG_context_priority");
 
@@ -1014,3 +1026,65 @@ int wlr_egl_dup_drm_fd(struct wlr_egl *egl) {
 	}
 	return fd;
 }
+
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd) {
+	if (!egl->procs.eglCreateSyncKHR) {
+		return EGL_NO_SYNC_KHR;
+	}
+
+	EGLint attribs[3] = { EGL_NONE };
+	int dup_fd = -1;
+	if (fence_fd >= 0) {
+		dup_fd = fcntl(fence_fd, F_DUPFD_CLOEXEC, 0);
+		if (dup_fd < 0) {
+			wlr_log_errno(WLR_ERROR, "dup failed");
+			return EGL_NO_SYNC_KHR;
+		}
+
+		attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+		attribs[1] = dup_fd;
+		attribs[2] = EGL_NONE;
+	}
+
+	EGLSyncKHR sync = egl->procs.eglCreateSyncKHR(egl->display,
+		EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+	if (sync == EGL_NO_SYNC_KHR) {
+		wlr_log(WLR_ERROR, "eglCreateSyncKHR failed");
+		if (dup_fd >= 0) {
+			close(dup_fd);
+		}
+	}
+	return sync;
+}
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (sync == EGL_NO_SYNC_KHR) {
+		return;
+	}
+	assert(egl->procs.eglDestroySyncKHR);
+	if (egl->procs.eglDestroySyncKHR(egl->display, sync) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglDestroySyncKHR failed");
+	}
+}
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (!egl->procs.eglDupNativeFenceFDANDROID) {
+		return -1;
+	}
+
+	int fd = egl->procs.eglDupNativeFenceFDANDROID(egl->display, sync);
+	if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+		wlr_log(WLR_ERROR, "eglDupNativeFenceFDANDROID failed");
+		return -1;
+	}
+
+	return fd;
+}
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (egl->procs.eglWaitSyncKHR(egl->display, sync, 0) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglWaitSyncKHR failed");
+		return false;
+	}
+	return true;
+}
diff --git a/render/gles2/pass.c b/render/gles2/pass.c
index 9177b0a1fafb9269bfaa44caa466e4f6ede57531..2942ab587d24d216c2cd7b0f57b4ed5346ac8570 100644
--- a/render/gles2/pass.c
+++ b/render/gles2/pass.c
@@ -2,8 +2,11 @@
 #include <assert.h>
 #include <pixman.h>
 #include <time.h>
+#include <unistd.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/util/transform.h>
+#include "render/egl.h"
 #include "render/gles2.h"
 #include "types/wlr_matrix.h"
 
@@ -21,6 +24,7 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 	struct wlr_gles2_render_pass *pass = get_render_pass(wlr_pass);
 	struct wlr_gles2_renderer *renderer = pass->buffer->renderer;
 	struct wlr_gles2_render_timer *timer = pass->timer;
+	bool ok = false;
 
 	push_gles2_debug(renderer);
 
@@ -36,16 +40,40 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 		clock_gettime(CLOCK_MONOTONIC, &timer->cpu_end);
 	}
 
-	glFlush();
+	if (pass->signal_timeline != NULL) {
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, -1);
+		if (sync == EGL_NO_SYNC_KHR) {
+			goto out;
+		}
+
+		int sync_file_fd = wlr_egl_dup_fence_fd(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (sync_file_fd < 0) {
+			goto out;
+		}
+
+		bool ok = wlr_drm_syncobj_timeline_import_sync_file(pass->signal_timeline, pass->signal_point, sync_file_fd);
+		close(sync_file_fd);
+		if (!ok) {
+			goto out;
+		}
+	} else {
+		glFlush();
+	}
+
+	ok = true;
+
+out:
 	glBindFramebuffer(GL_FRAMEBUFFER, 0);
 
 	pop_gles2_debug(renderer);
 	wlr_egl_restore_context(&pass->prev_ctx);
 
+	wlr_drm_syncobj_timeline_unref(pass->signal_timeline);
 	wlr_buffer_unlock(pass->buffer->buffer);
 	free(pass);
 
-	return true;
+	return ok;
 }
 
 static void render(const struct wlr_box *box, const pixman_region32_t *clip, GLint attrib) {
@@ -175,6 +203,27 @@ static void render_pass_add_texture(struct wlr_render_pass *wlr_pass,
 	src_fbox.height /= options->texture->height;
 
 	push_gles2_debug(renderer);
+
+	if (options->wait_timeline != NULL) {
+		int sync_file_fd =
+			wlr_drm_syncobj_timeline_export_sync_file(options->wait_timeline, options->wait_point);
+		if (sync_file_fd < 0) {
+			return;
+		}
+
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, sync_file_fd);
+		close(sync_file_fd);
+		if (sync == EGL_NO_SYNC_KHR) {
+			return;
+		}
+
+		bool ok = wlr_egl_wait_sync(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (!ok) {
+			return;
+		}
+	}
+
 	setup_blending(!texture->has_alpha && alpha == 1.0 ?
 		WLR_RENDER_BLEND_MODE_NONE : options->blend_mode);
 
@@ -247,7 +296,8 @@ static const char *reset_status_str(GLenum status) {
 }
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer) {
+		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+		struct wlr_drm_syncobj_timeline *signal_timeline, uint64_t signal_point) {
 	struct wlr_gles2_renderer *renderer = buffer->renderer;
 	struct wlr_buffer *wlr_buffer = buffer->buffer;
 
@@ -275,6 +325,10 @@ struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *b
 	pass->buffer = buffer;
 	pass->timer = timer;
 	pass->prev_ctx = *prev_ctx;
+	if (signal_timeline != NULL) {
+		pass->signal_timeline = wlr_drm_syncobj_timeline_ref(signal_timeline);
+		pass->signal_point = signal_point;
+	}
 
 	matrix_projection(pass->projection_matrix, wlr_buffer->width, wlr_buffer->height,
 		WL_OUTPUT_TRANSFORM_FLIPPED_180);
diff --git a/render/gles2/renderer.c b/render/gles2/renderer.c
index 4694b2a8f8aa4151c305a976222f10227611b20d..3eeb1ba9c199ddd7a26ead06ba502efb5a0622cd 100644
--- a/render/gles2/renderer.c
+++ b/render/gles2/renderer.c
@@ -259,7 +259,8 @@ static struct wlr_render_pass *gles2_begin_buffer_pass(struct wlr_renderer *wlr_
 		return NULL;
 	}
 
-	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer, &prev_ctx, timer);
+	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer,
+		&prev_ctx, timer, options->signal_timeline, options->signal_point);
 	if (!pass) {
 		return NULL;
 	}
@@ -683,6 +684,9 @@ struct wlr_renderer *wlr_gles2_renderer_create(struct wlr_egl *egl) {
 
 	get_gles2_shm_formats(renderer, &renderer->shm_texture_formats);
 
+	renderer->wlr_renderer.features.timeline =
+		egl->procs.eglDupNativeFenceFDANDROID && egl->procs.eglWaitSyncKHR;
+
 	return &renderer->wlr_renderer;
 
 error:
diff --git a/types/output/cursor.c b/types/output/cursor.c
index 4d5a3706190859f21ee3848b4069d6b3dd201950..144305b9bcdc40d194b627da2dd18d11b5581802 100644
--- a/types/output/cursor.c
+++ b/types/output/cursor.c
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <wlr/interfaces/wlr_output.h>
 #include <wlr/render/swapchain.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/util/log.h>
@@ -257,6 +258,8 @@ static struct wlr_buffer *render_cursor_buffer(struct wlr_output_cursor *cursor)
 		.src_box = cursor->src_box,
 		.dst_box = dst_box,
 		.transform = transform,
+		.wait_timeline = cursor->wait_timeline,
+		.wait_point = cursor->wait_point,
 	});
 
 	if (!wlr_render_pass_submit(pass)) {
@@ -341,20 +344,22 @@ bool wlr_output_cursor_set_buffer(struct wlr_output_cursor *cursor,
 	hotspot_y /= cursor->output->scale;
 
 	return output_cursor_set_texture(cursor, texture, true, &src_box,
-		dst_width, dst_height, WL_OUTPUT_TRANSFORM_NORMAL, hotspot_x, hotspot_y);
+		dst_width, dst_height, WL_OUTPUT_TRANSFORM_NORMAL, hotspot_x, hotspot_y,
+		NULL, 0);
 }
 
 static void output_cursor_handle_renderer_destroy(struct wl_listener *listener,
 		void *data) {
 	struct wlr_output_cursor *cursor = wl_container_of(listener, cursor, renderer_destroy);
 	output_cursor_set_texture(cursor, NULL, false, NULL, 0, 0,
-		WL_OUTPUT_TRANSFORM_NORMAL, 0, 0);
+		WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, NULL, 0);
 }
 
 bool output_cursor_set_texture(struct wlr_output_cursor *cursor,
 		struct wlr_texture *texture, bool own_texture, const struct wlr_fbox *src_box,
 		int dst_width, int dst_height, enum wl_output_transform transform,
-		int32_t hotspot_x, int32_t hotspot_y) {
+		int32_t hotspot_x, int32_t hotspot_y,
+		struct wlr_drm_syncobj_timeline *wait_timeline, uint64_t wait_point) {
 	struct wlr_output *output = cursor->output;
 
 	output_cursor_reset(cursor);
@@ -381,6 +386,15 @@ bool output_cursor_set_texture(struct wlr_output_cursor *cursor,
 	cursor->texture = texture;
 	cursor->own_texture = own_texture;
 
+	wlr_drm_syncobj_timeline_unref(cursor->wait_timeline);
+	if (wait_timeline != NULL) {
+		cursor->wait_timeline = wlr_drm_syncobj_timeline_ref(wait_timeline);
+		cursor->wait_point = wait_point;
+	} else {
+		cursor->wait_timeline = NULL;
+		cursor->wait_point = 0;
+	}
+
 	wl_list_remove(&cursor->renderer_destroy.link);
 	if (texture != NULL) {
 		cursor->renderer_destroy.notify = output_cursor_handle_renderer_destroy;
@@ -457,6 +471,7 @@ void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor) {
 	if (cursor->own_texture) {
 		wlr_texture_destroy(cursor->texture);
 	}
+	wlr_drm_syncobj_timeline_unref(cursor->wait_timeline);
 	wl_list_remove(&cursor->link);
 	free(cursor);
 }
diff --git a/types/output/output.c b/types/output/output.c
index 818f4549e9245968a4f6093eb3165bee5a493e45..1c9a007796aa4906d2f61c820a4e0ac5453bcf21 100644
--- a/types/output/output.c
+++ b/types/output/output.c
@@ -563,9 +563,19 @@ static bool output_basic_test(struct wlr_output *output,
 			wlr_log(WLR_DEBUG, "Primary buffer size mismatch");
 			return false;
 		}
-	} else if (state->tearing_page_flip) {
-		wlr_log(WLR_ERROR, "Trying to commit a tearing page flip without a buffer?");
-		return false;
+	} else {
+		if (state->tearing_page_flip) {
+			wlr_log(WLR_ERROR, "Tried to commit a tearing page flip without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set wait timeline without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set signal timeline without a buffer");
+			return false;
+		}
 	}
 
 	if (state->committed & WLR_OUTPUT_STATE_RENDER_FORMAT) {
@@ -632,6 +642,12 @@ static bool output_basic_test(struct wlr_output *output,
 		}
 	}
 
+	if ((state->committed & (WLR_OUTPUT_STATE_WAIT_TIMELINE | WLR_OUTPUT_STATE_SIGNAL_TIMELINE)) &&
+			!output->timeline) {
+		wlr_log(WLR_DEBUG, "Wait/signal timelines are not supported for this output");
+		return false;
+	}
+
 	return true;
 }
 
diff --git a/types/output/state.c b/types/output/state.c
index 0909b3e8ac15927c2e94c9c80028dee16fcadaf6..465b54adac05d40195101eaf253ffa88de79e3ce 100644
--- a/types/output/state.c
+++ b/types/output/state.c
@@ -1,5 +1,6 @@
 #include <stdlib.h>
 #include <string.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/util/log.h>
 #include "types/wlr_output.h"
 
@@ -16,6 +17,8 @@ void wlr_output_state_finish(struct wlr_output_state *state) {
 	state->buffer = NULL;
 	pixman_region32_fini(&state->damage);
 	free(state->gamma_lut);
+	wlr_drm_syncobj_timeline_unref(state->wait_timeline);
+	wlr_drm_syncobj_timeline_unref(state->signal_timeline);
 }
 
 void wlr_output_state_set_enabled(struct wlr_output_state *state,
@@ -114,16 +117,36 @@ void wlr_output_state_set_layers(struct wlr_output_state *state,
 	state->layers_len = layers_len;
 }
 
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+		struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point) {
+	state->committed |= WLR_OUTPUT_STATE_WAIT_TIMELINE;
+	wlr_drm_syncobj_timeline_unref(state->wait_timeline);
+	state->wait_timeline = wlr_drm_syncobj_timeline_ref(timeline);
+	state->wait_point = src_point;
+}
+
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+		struct wlr_drm_syncobj_timeline *timeline, uint64_t dst_point) {
+	state->committed |= WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
+	wlr_drm_syncobj_timeline_unref(state->signal_timeline);
+	state->signal_timeline = wlr_drm_syncobj_timeline_ref(timeline);
+	state->signal_point = dst_point;
+}
+
 bool wlr_output_state_copy(struct wlr_output_state *dst,
 		const struct wlr_output_state *src) {
 	struct wlr_output_state copy = *src;
 	copy.committed &= ~(WLR_OUTPUT_STATE_BUFFER |
 		WLR_OUTPUT_STATE_DAMAGE |
-		WLR_OUTPUT_STATE_GAMMA_LUT);
+		WLR_OUTPUT_STATE_GAMMA_LUT |
+		WLR_OUTPUT_STATE_WAIT_TIMELINE |
+		WLR_OUTPUT_STATE_SIGNAL_TIMELINE);
 	copy.buffer = NULL;
 	pixman_region32_init(&copy.damage);
 	copy.gamma_lut = NULL;
 	copy.gamma_lut_size = 0;
+	copy.wait_timeline = NULL;
+	copy.signal_timeline = NULL;
 
 	if (src->committed & WLR_OUTPUT_STATE_BUFFER) {
 		wlr_output_state_set_buffer(&copy, src->buffer);
@@ -142,6 +165,15 @@ bool wlr_output_state_copy(struct wlr_output_state *dst,
 		}
 	}
 
+	if (src->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+		wlr_output_state_set_wait_timeline(&copy, src->wait_timeline,
+			src->wait_point);
+	}
+	if (src->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+		wlr_output_state_set_signal_timeline(&copy, src->signal_timeline,
+			src->signal_point);
+	}
+
 	wlr_output_state_finish(dst);
 	*dst = copy;
 	return true;
diff --git a/types/scene/surface.c b/types/scene/surface.c
index e0f61f510687f27271bc26942e41c4eb667e737e..a974619371d68272544319008e723729f9549c13 100644
--- a/types/scene/surface.c
+++ b/types/scene/surface.c
@@ -4,6 +4,7 @@
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/util/transform.h>
 #include "types/wlr_scene.h"
@@ -140,6 +141,7 @@ static void surface_reconfigure(struct wlr_scene_surface *scene_surface) {
 
 	if (width <= 0 || height <= 0) {
 		wlr_scene_buffer_set_buffer(scene_buffer, NULL);
+		wlr_scene_buffer_set_wait_timeline(scene_buffer, NULL, 0);
 		pixman_region32_fini(&opaque);
 		return;
 	}
@@ -169,6 +171,22 @@ static void surface_reconfigure(struct wlr_scene_surface *scene_surface) {
 	}
 
 	pixman_region32_fini(&opaque);
+
+	struct wlr_drm_syncobj_timeline *wait_timeline = NULL;
+	uint64_t wait_point = 0;
+	struct wlr_linux_drm_syncobj_surface_v1_state *syncobj_surface_state =
+		wlr_linux_drm_syncobj_v1_get_surface_state(surface);
+	if (syncobj_surface_state != NULL) {
+		wait_timeline = syncobj_surface_state->acquire_timeline;
+		wait_point = syncobj_surface_state->acquire_point;
+	}
+	wlr_scene_buffer_set_wait_timeline(scene_buffer, wait_timeline, wait_point);
+
+	if (syncobj_surface_state != NULL && surface->buffer != NULL &&
+			(surface->current.committed & WLR_SURFACE_STATE_BUFFER)) {
+		wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(syncobj_surface_state,
+			&surface->buffer->base);
+	}
 }
 
 static void handle_scene_surface_surface_commit(
diff --git a/types/scene/wlr_scene.c b/types/scene/wlr_scene.c
index e3e49584d85953c0262ccc889f0f9506a5a362cb..866772be0626e318184c3bef241371775e8af278 100644
--- a/types/scene/wlr_scene.c
+++ b/types/scene/wlr_scene.c
@@ -3,6 +3,7 @@
 #include <string.h>
 #include <wlr/backend.h>
 #include <wlr/render/swapchain.h>
+#include <wlr/render/drm_syncobj.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_damage_ring.h>
@@ -117,6 +118,7 @@ void wlr_scene_node_destroy(struct wlr_scene_node *node) {
 		scene_buffer_set_buffer(scene_buffer, NULL);
 		scene_buffer_set_texture(scene_buffer, NULL);
 		pixman_region32_fini(&scene_buffer->opaque_region);
+		wlr_drm_syncobj_timeline_unref(scene_buffer->wait_timeline);
 	} else if (node->type == WLR_SCENE_NODE_TREE) {
 		struct wlr_scene_tree *scene_tree = wlr_scene_tree_from_node(node);
 
@@ -898,6 +900,18 @@ void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer,
 	scene_node_update(&scene_buffer->node, NULL);
 }
 
+void wlr_scene_buffer_set_wait_timeline(struct wlr_scene_buffer *scene_buffer,
+		struct wlr_drm_syncobj_timeline *timeline, uint64_t src_point) {
+	wlr_drm_syncobj_timeline_unref(scene_buffer->wait_timeline);
+	if (timeline != NULL) {
+		scene_buffer->wait_timeline = wlr_drm_syncobj_timeline_ref(timeline);
+		scene_buffer->wait_point = src_point;
+	} else {
+		scene_buffer->wait_timeline = NULL;
+		scene_buffer->wait_point = 0;
+	}
+}
+
 static struct wlr_texture *scene_buffer_get_texture(
 		struct wlr_scene_buffer *scene_buffer, struct wlr_renderer *renderer) {
 	if (scene_buffer->buffer == NULL || scene_buffer->texture != NULL) {
@@ -1244,6 +1258,8 @@ static void scene_entry_render(struct render_list_entry *entry, const struct ren
 			.filter_mode = scene_buffer->filter_mode,
 			.blend_mode = pixman_region32_not_empty(&opaque) ?
 				WLR_RENDER_BLEND_MODE_PREMULTIPLIED : WLR_RENDER_BLEND_MODE_NONE,
+			.wait_timeline = scene_buffer->wait_timeline,
+			.wait_point = scene_buffer->wait_point,
 		});
 
 		struct wlr_scene_output_sample_event sample_event = {
@@ -1406,6 +1422,14 @@ struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene,
 		prev_output_link = &current_output->link;
 	}
 
+	int drm_fd = wlr_backend_get_drm_fd(output->backend);
+	if (drm_fd >= 0 && output->timeline && output->renderer != NULL && output->renderer->features.timeline) {
+		scene_output->in_timeline = wlr_drm_syncobj_timeline_create(drm_fd);
+		if (scene_output->in_timeline == NULL) {
+			return NULL;
+		}
+	}
+
 	scene_output->index = prev_output_index + 1;
 	assert(scene_output->index < 64);
 	wl_list_insert(prev_output_link, &scene_output->link);
@@ -1454,7 +1478,7 @@ void wlr_scene_output_destroy(struct wlr_scene_output *scene_output) {
 	wl_list_remove(&scene_output->output_commit.link);
 	wl_list_remove(&scene_output->output_damage.link);
 	wl_list_remove(&scene_output->output_needs_frame.link);
-
+	wlr_drm_syncobj_timeline_unref(scene_output->in_timeline);
 	wl_array_release(&scene_output->render_list);
 	free(scene_output);
 }
@@ -1669,6 +1693,9 @@ static bool scene_entry_try_direct_scanout(struct render_list_entry *entry,
 	}
 
 	wlr_output_state_set_buffer(&pending, buffer->buffer);
+	if (buffer->wait_timeline != NULL) {
+		wlr_output_state_set_wait_timeline(&pending, buffer->wait_timeline, buffer->wait_point);
+	}
 
 	if (!wlr_output_test_state(scene_output->output, &pending)) {
 		wlr_output_state_finish(&pending);
@@ -1879,10 +1906,13 @@ bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output,
 		timer->pre_render_duration = timespec_to_nsec(&duration);
 	}
 
+	scene_output->in_point++;
 	struct wlr_render_pass *render_pass = wlr_renderer_begin_buffer_pass(output->renderer, buffer,
 			&(struct wlr_buffer_pass_options){
 		.timer = timer ? timer->render_timer : NULL,
 		.color_transform = options->color_transform,
+		.signal_timeline = scene_output->in_timeline,
+		.signal_point = scene_output->in_point,
 	});
 	if (render_pass == NULL) {
 		wlr_buffer_unlock(buffer);
@@ -1989,6 +2019,11 @@ bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output,
 	wlr_output_state_set_buffer(state, buffer);
 	wlr_buffer_unlock(buffer);
 
+	if (scene_output->in_timeline != NULL) {
+		wlr_output_state_set_wait_timeline(state, scene_output->in_timeline,
+			scene_output->in_point);
+	}
+
 	return true;
 }
 
diff --git a/types/wlr_cursor.c b/types/wlr_cursor.c
index 77ab2fb708f22169ce3dfd12aca1726873d14ec8..a2489fbd115657d59451ea841e9261af1483c938 100644
--- a/types/wlr_cursor.c
+++ b/types/wlr_cursor.c
@@ -7,6 +7,7 @@
 #include <wlr/types/wlr_cursor.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
 #include <wlr/types/wlr_input_device.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_pointer.h>
@@ -534,7 +535,7 @@ static void cursor_output_cursor_update(struct wlr_cursor_output_cursor *output_
 
 		output_cursor_set_texture(output_cursor->output_cursor, texture, true,
 			&src_box, dst_width, dst_height, WL_OUTPUT_TRANSFORM_NORMAL,
-			hotspot_x, hotspot_y);
+			hotspot_x, hotspot_y, NULL, 0);
 	} else if (cur->state->surface != NULL) {
 		struct wlr_surface *surface = cur->state->surface;
 
@@ -547,9 +548,24 @@ static void cursor_output_cursor_update(struct wlr_cursor_output_cursor *output_
 		int dst_width = surface->current.width;
 		int dst_height = surface->current.height;
 
+		struct wlr_linux_drm_syncobj_surface_v1_state *syncobj_surface_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(surface);
+		struct wlr_drm_syncobj_timeline *wait_timeline = NULL;
+		uint64_t wait_point = 0;
+		if (syncobj_surface_state != NULL) {
+			wait_timeline = syncobj_surface_state->acquire_timeline;
+			wait_point = syncobj_surface_state->acquire_point;
+		}
+
 		output_cursor_set_texture(output_cursor->output_cursor, texture, false,
 			&src_box, dst_width, dst_height, surface->current.transform,
-			hotspot_x, hotspot_y);
+			hotspot_x, hotspot_y, wait_timeline, wait_point);
+
+		if (syncobj_surface_state != NULL && surface->buffer != NULL &&
+				(surface->current.committed & WLR_SURFACE_STATE_BUFFER)) {
+			wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(syncobj_surface_state,
+				&surface->buffer->base);
+		}
 
 		if (output_cursor->output_cursor->visible) {
 			wlr_surface_send_enter(surface, output);
diff --git a/types/wlr_linux_drm_syncobj_v1.c b/types/wlr_linux_drm_syncobj_v1.c
index 82ace2d78b037381107e37754da98a282432ea60..bc2c79dc70eea06b9cf13d7ddc2e2d6c276a3f99 100644
--- a/types/wlr_linux_drm_syncobj_v1.c
+++ b/types/wlr_linux_drm_syncobj_v1.c
@@ -467,3 +467,40 @@ wlr_linux_drm_syncobj_v1_get_surface_state(struct wlr_surface *wlr_surface) {
 	}
 	return &surface->current;
 }
+
+struct release_signaller {
+	struct wlr_drm_syncobj_timeline *timeline;
+	uint64_t point;
+	struct wl_listener buffer_release;
+};
+
+static void release_signaller_handle_buffer_release(struct wl_listener *listener, void *data) {
+	struct release_signaller *signaller = wl_container_of(listener, signaller, buffer_release);
+
+	if (drmSyncobjTimelineSignal(signaller->timeline->drm_fd, &signaller->timeline->handle,
+			&signaller->point, 1) != 0) {
+		wlr_log(WLR_ERROR, "drmSyncobjTimelineSignal() failed");
+	}
+
+	wlr_drm_syncobj_timeline_unref(signaller->timeline);
+	free(signaller);
+}
+
+bool wlr_linux_drm_syncobj_v1_state_signal_release_with_buffer(
+		struct wlr_linux_drm_syncobj_surface_v1_state *state, struct wlr_buffer *buffer) {
+	assert(buffer->n_locks > 0);
+	assert(state->release_timeline != NULL);
+
+	struct release_signaller *signaller = calloc(1, sizeof(*signaller));
+	if (signaller == NULL) {
+		return false;
+	}
+
+	signaller->timeline = wlr_drm_syncobj_timeline_ref(state->release_timeline);
+	signaller->point = state->release_point;
+
+	signaller->buffer_release.notify = release_signaller_handle_buffer_release;
+	wl_signal_add(&buffer->events.release, &signaller->buffer_release);
+
+	return true;
+}
-- 
2.45.2

